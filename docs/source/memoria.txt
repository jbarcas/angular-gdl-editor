Desarrollo de un editor de guías clínicas (GDL) basadas en arquetipos utilizando tecnologías web
================================================================================================
Jesús Barros Castro <j.barros@udc.es>
v0.0.1, Julio 2017
:revremark: Primera versión de la memoria
:lang:      es
:imagesdir: ./images
:iconsdir: ./images/icons
:homepage: https://github.com/jbarcas/angular-gdl-editor
:ascii-ids:
:grid: all
:frame: topbot

[abstract]
--
Expresar y compartir conocimiento informatizado que dé soporte a la decisión clínica independientemente del
idioma y de plataformas técnicas ha sido un gran desafío durante mucho tiempo. Los dos retos principales a
afrontar para compartir lógica de decisión entre diferentes sistemas son, por un lado, la ausencia de modelos de
información clínica de uso colectivo y, por otro, la escasez de soporte para los diferentes recursos terminológicos.

Para expresar la lógica que da soporte a la decisión médica se necesita un modelo de representación de guías
clínicas. Para que dicha lógica pueda ser interpretada automáticamente entre los sistemas sanitarios tiene que contar
con la característica de ser semánticamente interoperable. __open__EHR, comunidad virtual que trabaja en
el desarrollo de especificaciones para la interoperabilidad de registros clínicos electrónicos entre sistemas, ha
desarrollado la especificación del _Guideline Definition Language_(_GDL_), un lenguaje formal
diseñado para expresar lógica de soporte a la decisión de forma interoperable, el cual, recientemente, ha pasado
a formar parte del núcleo de la plataforma __open__EHR. Ha sido diseñado para ser independiente de lenguajes
naturales y de terminologías clínicas haciendo uso, para ello, de los diseños del Modelo de Referencia y del Modelo
de Arquetipos de __open__EHR.

El principal objetivo de este proyecto ha sido la elaboración de una herramienta web para la edición de guías
clínicas expresadas en lenguaje GDL. La comunidad no disponía de una herramienta de gestión de dichas guías con un
enfoque colaborativo como el que puede ofrecer una aplicación web. Lo que se pretende es que sean los propios
profesionales sanitarios--los que tienen el conocimiento necesario--los que elaboren las guías clínicas de una manera
colaborativa y consensuada, con el fin de poder utilizarlas de manera exitosa en la práctica médica.

El resultado de este proyecto es un software capaz de crear, editar y gestionar guías clínicas en formato GDL, las guías
son validadas en el servidor de la aplicación (denominado _Knowledge Manager Server_, o _KM server_), denegándose la
petición de envío cuando la guía posee algún error de sintaxis. Se ha desarrollado una aplicación modular en
AngularJS, herramienta para el desarrollo de _aplicaciones web de una sola página_ basado en el
patrón de arquitectura Modelo-vista-controlador, por lo que existe una clara separación entre los datos (modelo), la
lógica de la aplicación, (controlador) y la presentación de la información (vista). AngularJS favorece la
reutilización de componentes, inyección de dependencias y un testeo unitario y _end-to-end_ de forma sencilla y
eficiente. La metodología de desarrollo ágil Scrum ha ayudado a reducir considerablemente los ciclos de desarrollo y
ha asegurado que al final de cada ciclo se hubiesen desarrollado ciertas funcionalidades operativas de aplicación.

*Palabras clave*
Guías clínicas, arquetipos clínicos, sistema de soporte a la decisión, interoperabilidad semántica, AngularJS, REST.
--

Introducción
------------
La toma de decisiones es el proceso mediante el que se realiza la elección de una alternativa para resolver un
problema<<TURB11>>. Está presente cotidianamente tanto en la actividad humana como en la de las organizaciones. La clave
del éxito está en tomar buenas decisiones. Es necesario que se cumplan ciertos requisitos para tener éxito tomando
decisiones, como son:

* Conocimiento en profundidad del dominio en cuestión.
* Experiencia.
* Información disponible:
** abarcable por un conjunto de personas.
** no siempre orientable al proceso analítico.
* Uso de metodologías de análisis sencillas e intuitivas.

.Toma de decisiones.
image::toma-de-decisiones.png[scaledwidth="50%"]

La toma de decisiones utiliza como materias primas la _información_ y el _conocimiento_<<VERC09>>, ya que sin estas
sería
imposible evaluar las opciones existentes o el desarrollo de nuevas alternativas. El contexto de este Trabajo Fin de
Máster (TFM) es el entorno médico-sanitario, el cual se encuentra sometido constantemente a la toma de decisiones y
donde la representación de la información y del conocimiento juega un papel de vital importancia. Para interpretar
los datos y poder transformarlos en información relevante es necesario un _sistema de información_. De esta
información, con su respectivo proceso de análisis, se puede obtener conocimiento de gran valor para la medicina y,
por lo tanto, para la sociedad. Además de los sistemas de información, existen sistemas diseñados especialmente para
ayudar en el proceso de la toma de decisiones, que se conocen como _sistemas de soporte a decisiones_ o _sistemas de
apoyo a la decisión_. En esta memoria de TFM se presenta el proceso de desarrollo de una herramienta para la creación
y edición de guías clínicas interoperables que serán utilizadas en este tipo de sistemas.

El requisito de que las guías clínicas sean interoperables obliga a que haya que seguir un estándar de
interoperabilidad. GDL es un lenguaje para la definición de guías basado en arquetipos clínicosfootnote:[Arquetipo
clínico: estructura de datos para la representación formal de un concepto del ámbito sanitario]. La utilización de
arquetipos para representar los conceptos de las guías, y el uso de terminologías clínicas como vocabulario común
para la codificación de términos va a permitir alcanzar la interoperabilidad semántica necesaria para el intercambio
de conocimiento clínico entre sistemas sanitarios.

El concepto de apoyo a las decisiones es muy
antiguo <<KEEN87>> y ha evolucionado principalmente desde dos áreas de investigación: los estudios teóricos de
organización de la toma de decisiones, desarrollados en el Carnegie Institute of Technology a principios de los años
60 y el trabajo técnico sobre sistemas informáticos interactivos, llevados a cabo principalmente en el Instituto
Tecnológico de Massachusets en la década de los 60. Posteriormente, en la década de los 70, los sistemas de apoyo a
las decisiones pasan a convertirse en un campo de investigación como tal. Durante la década de los 80 la
investigación en este campo ganó intensidad, surgiendo así los Sistemas de Información Ejecutiva, los Sistemas de
Apoyo a la Decisión en Grupo y los Sistemas Organizacionales de Apoyo a la Decisión. A partir de 1990
el procesamiento analítico en línea (OLAP) y los almacenes de datos fomentaron la ampliación del ámbito de los
sistemas de soporte a la decisión. Con el cambio de milenio se introdujeron aplicaciones analíticas basadas en web
enfocadas a la administración y creación de conocimiento sobre el entorno en organizaciones y empresas.

*Breve historia de los Sistemas de Soporte a la Decisión Clínica (SSDC)* +
En el ámbito de la salud, las decisiones clínicas se toman, por lo general, mediante razonamiento deductivo, utilizando
el conocimiento que tienen los profesionales sanitarios sobre la fisiopatología humana teniendo en cuenta la
información disponible para cada paciente.

Parece bastante obvio que la experiencia de otros médicos y profesionales de la salud puede ayudar a tomar
decisiones. A principios de los años 60 ya se  empezaron a  dedicar esfuerzos para crear sistemas de soporte a la
decisión clínica <<BONI04>>. Incluso una década antes, se trabajó con intensidad en la realización de diagnósticos a
partir de la información que los médicos habían almacenado en sus computadoras, se basaban en reglas lógicas básicas.
Dos ejemplos clásicos son el sistema de diagnóstico de alteraciones electrolíticas de Bleich <<BLEI69>> y el realizado
por Warner _et al_. <<WARN61>> basado en la realización de razonamientos probabilísticos mediante el uso  intensivo
del teorema de Bayes. Hasta ese momento se fundaron lo que fueron las bases teóricas del desarrollo de los SSDC.
Durante las dos décadas siguientes se desarrollaron los primeros SSDC basados en grandes ordenadores. Sin
embargo, no fue hasta los 80 y 90, con la llegada de los ordenadores personales y el uso generalizado de los mismos,
cuando se aprovecharon potencialmente este tipo de sistemas. Hoy en día el soporte a la decisión clínica forma parte
de muchos sistemas sanitarios, se está invirtiendo mucho esfuerzo por parte de las instituciones médicas y compañías
de software para producir SSDC viables para apoyar en todos los aspectos de la práctica clínica. A pesar de estos
esfuerzos por parte de las instituciones para producir y utilizar estos sistemas, todavía no se ha alcanzado la
adopción y la aceptación generalizada de la mayoría de las ofertas, y esto es debido principalmente a la escasez de
modelos de información clínicos compartidos entre sistemas sanitarios.

*Las Tecnologías de la Información y las Comunicaciones (TIC) en los sistemas sanitarios* +
Actualmente la utilización de las TIC en los sistemas sanitarios se ha convertido en indispensable. Hoy en día todavía
estamos en plena transición de una historia clínica convencional a una <<X1, Historia Clínica Electrónica>> (HCE) que introduce
una serie de mejoras relacionadas con la inviolabilidad de los datos, la privacidad del paciente, accesibilidad,
disponibilidad, mejoras contra la pérdida de información, durabilidad, legibilidad, identificación del profesional
clínico, redundancia, errores en la consignación de datos y algo muy importante: la estandarización de datos. Ya en
1990 empieza a surgir la necesidad de representación genérica para la comunicación de registros de historia clínica
entre sistemas. La HCE puede almacenar, cuanto menos, la misma información que podría
almacenarse en un archivo médico convencional. En los últimos 20 años los sistemas de HCE han sufrido una gran
evolución <<LEHM06>> y se han implementado una gran cantidad de proyectos orientados a la eSalud.

*Interoperabilidad* +
Los sistemas de salud actuales requieren para sí una característica fundamental para garantizar la continuidad
asistencialfootnote:[Continuidad asistencial: concepto que define el proceso, centrado en el paciente, en el cual
intervienen diferentes profesionales sanitarios en diferentes periodos de tiempo y lugares con el objetivo
compartido de mejorar la calidad de la asistencia prestada.], se requiere que la informaciónclínica sea representada
de una manera interoperable, de modo que diferentes organizaciones puedan hacer uso de dicha información
independientemente de quién, cómo y cuándo se haya generado. La continuidad asistencial del paciente es indispensable
en multitud de situaciones como cambios de residencia de los pacientes, cambios organizativos, cambios de niveles
asistenciales, etc. La manera de conseguir la deseada interoperabilidad es aplicando la normalización. Las normas o
estándares proporcionan la base sobre la que poder crear acuerdos con un objetivo en común, en este caso la
continuidad asistencial. http://www.openehr.org/[__open__EHR]footnote:[EHR son las siglas de Electronic Health
Record: Historia Clínica Electrónica en español.] es una comunidad virtual que trabaja en la estandarización de la
HCE, garantizando una interoperabilidad universal entre todo tipo de sistemas de información clínicos. Actualmente se
está utilizando en multitud de organizaciones:

* Soluciones ya implantadasfootnote:[http://www.openehr.org/who_is_using_openehr/healthcare_providers_and_authorities]
* Proyectos de investigación financiadosfootnote:[http://www.openehr.org/who_is_using_openehr/funded_research_projects]
* Organizaciones sin ánimo de lucro y de código abiertofootnote:[http://www.openehr.org/who_is_using_openehr/nonprofit_and_open_source_organisation]
* Gobiernosfootnote:[http://www.openehr.org/who_is_using_openehr/governments]
* Investigación académicafootnote:[http://www.openehr.org/who_is_using_openehr/academic_research]

Como parte de su trabajo, la Fundación __open__EHR cuenta con una plataforma internacional de intercambio de
conocimiento clínico denominado http://www.openehr.org/ckm/[Clinical Knowledge Manager] (CKM), la cual ha reunido a
una comunidad Web 2.0 activa de personas motivadas en  promover un enfoque abierto e internacional de la informática
sanitaria. En estos momentos el CKM consiste en un repositorio de arquetipos clínicos, un repositorio de
plantillasfootnote:[Plantilla: arquetipo de alto nivel que agrega a otros arquetipos y forma una estructura
jerárquica para modelar un concepto más complejo, _e.g._ un informe de alta médica.] y cuenta con un proceso de
revisión formalizada para conseguir un  consenso y publicación de dichos arquetipos. Recientemente, la comunidad
__open__EHR ha decidido que el lenguaje GDL pase a formar parte del núcleo de especificaciones de la plataforma, por
lo que las guías clínicas en GDL serán incluidas dentro de la plataforma CKM.

Conseguir la deseada interoperabilidad en entornos sanitarios es una tarea compleja ya que las organizaciones
actúan, en cierto modo, como silos de información aislados, es decir, son autónomos a la hora de tomar sus propias
decisiones, de implantar los sistemas de información que cada una de ellas quiere. Esto se repite incluso dentro de
las propias organizaciones, un ejemplo claro podrían ser los propios servicios dentro de un hospital que, en
numerosas ocasiones, utilizan sistemas distintos. Surge, de esta manera, la necesidad de crear una metodología que
nos permita representar el conocimiento médico y, de este modo, poder separarlo de la información clínica existente
en los sistemas.

*Elementos para el cambio* +
Lo que diferencia a la medicina de otros entornos es la complejidad del conocimiento clínico y la velocidad con la
que este varía. Esto ocasionó durante mucho tiempo que no existiese un mecanismo para representar el conocimiento ni
para gestionarlo correctamente, por lo tanto, lo lógico fue buscar una estrategia que permitiese gestionar la
información clínica con sus características intrínsecas de forma adecuada. La mayoría de sistemas actuales se
desarrollan de tal forma que los conceptos del dominio médico se encuentran _hardcodeados_ al software y a los
modelos de bases de datos utilizados lo que impide que dicha información pueda ser compartida con otros sistemas.

Para solventar esta situación han surgido recientemente los estándares de interoperabilidad basados en modelos
duales (se verán en detalle en la <<modelos-duales>>). Lo que diferencia a estos estándares de otras normas es
que permiten separar la _información_ existente en los sistemas del _conocimiento_ médico, de manera que este último
pueda evolucionar sin alterar al primero, a la información almacenada en la base de datos. El modelo dual consta de
dos modelos de datos, uno para representar el conocimiento (Modelo de Arquetipos) y otro para representar la
información (Modelo de Referencia).

Por lo tanto, se necesita una representación correcta del conocimiento médico que permita comunicar la información
con su contexto de forma adecuada, sin que se permitan ambigüedades ni alteraciones de su significado durante el proceso
de transferencia. Un primer paso para esto es el uso de terminologías clínicas que aportan un vocabulario
común para codificar términos, pero el uso de terminologías no es suficiente, se necesita también un mecanismo que
permita representar las estructuras de datos, esto se consigue mediante los arquetipos clínicos y finalmente es
necesario un sistema que permita representar el contexto, para ello utilizaremos el Modelo de Referencia.

Objetivos
~~~~~~~~~
El objetivo principal de este proyecto consiste en el desarrollo de una aplicación web para la gestión de guías
clínicas basadas en arquetipos y expresadas en lenguaje GDL. Al estar GDL basado en una norma de interoperabilidad
semántica, esta herramienta permitirá a los profesionales sanitarios generar conocimiento clínico interoperable
semánticamente. Además, al hacer uso de tecnologías web y al ser integrada en el CKM de __open__EHR, permitirá
hacerlo de una manera colaborativa y consensuada.

Desde la fundación __open__EHR se demanda una herramienta de gestión de guías clínicas con un enfoque colaborativo,
que proporcione una usabilidad adecuada, con una interfaz sencilla, accesible y que sea modular, de manera que sea
sencillo añadir, modificar y eliminar funcionalidades. Esta herramienta estará preparada para ser integrada en la
plataforma CKM y supondrá el punto de partida hacia una serie de nuevas funcionalidades de gran utilidad para la
comunidad, como la edición colaborativa en tiempo real, la resolución de conflictos, la gestión de historial y de
versiones, etc. La aplicación se desarrollará siguiendo un enfoque de metodología ágil, adaptado a las
características y requerimientos de un Trabajo Fin de Máster (TFM).

Hasta el desarrollo de la aplicación objeto de este TFM, se disponía de una herramienta basada en tecnología Java
Swing que permite editar y ejecutar guías clínicas en GDL. Se trata de un software de escritorio independiente de la
plataforma CKM, que permite editar las guías de manera off-line. Por tratarse de un software _stand-alone_ que no se
encuentra integrado en CKM, representa una limitación en la colaboración e intercambio de conocimiento clínico entre
diferentes usuarios.

*Objetivos específicos* +
Como objetivos específicos, se plantean los siguientes:

* La aplicación desarrollada permitirá crear, editar y actualizar ficheros GDL a través de un navegador web.

* El software a construir se integrará con un sistema existente
(<<X4, Knowledge Manager>>)footnote:[http://www.cambiohealthcare.co.uk/wp-content/uploads/2016/02/C_CDS-Knowledge-manager.pdf],
dicho sistema se está utilizando actualmente en producción en 12 hospitales en Suecia.

* Se desarrollará siguiendo un _framework_ Modelo-vista-controlador (MVC), de manera que haya una separación clara entre
la lógica de negocio, el modelo y la vista de la aplicación, fomentando de esta manera la mantenibilidad y la
escalabilidad de la misma.

* La aplicación desarrollada deberá estar preparada para ser integrada con el CKM de __open__EHR
(http://www.openehr.org/ckm[www.openehr.org/ckm]). La aplicación se diseñará de manera que sus componentes puedan ser
fácilmente reutilizados y de forma que resulte sencillo incorporar nuevas funcionalidades.

* Se diseñará una interfaz de usuario sencilla e intuitiva, teniendo en cuenta aspectos de usabilidad, de forma que
el proceso de gestión de las guías clínicas resulte fácilmente asimilable por los expertos en el dominio clínico y
disfruten de una experiencia agradable durante el uso de la herramienta.

Fundamentos
-----------

Aplicaciones web
~~~~~~~~~~~~~~~~
En la actualidad millones de negocios usan Internet como canal de comunicaciones de bajo coste. Internet les permite
intercambiar información con su mercado objetivo y realizar transacciones de una manera rápida y sencilla. Sin
embargo, un acuerdo efectivo solamente es posible cuando el negocio es capaz de capturar y almacenar todos los datos
necesarios y tener un medio que permita el procesamiento de dicha información y la presentación de los resultados al
usuario.

En ingeniería del software se denomina aplicación web <<WEBA17>> a aquellas herramientas que los usuarios
pueden utilizar accediendo a un servidor web a través de Internet o de una intranet mediante un
navegador. Las aplicaciones web son populares debido a lo práctico del navegador web como
cliente ligero, a la independencia del sistema operativo, así como a la facilidad para actualizar y
mantener aplicaciones web sin distribuir e instalar software a miles de potenciales usuarios.
Existen aplicaciones como los _webmails_, _wikis_, _weblogs_, tiendas en línea, buscadores etc. que
son ejemplos bien conocidos de aplicaciones web.

Es importante mencionar que una página web puede contener elementos que permiten una
comunicación activa entre el usuario y la información. Esto permite que el usuario acceda a los
datos de modo interactivo, gracias a que la página responderá a cada una de sus acciones, como
por ejemplo rellenar y enviar formularios, participar en juegos diversos y acceder a gestores de
bases de datos de todo tipo. Las aplicaciones web usan una combinación de _scripts_ de servidor (PHP, ASP o cualquier
_backend_ desarrollado en otros lenguajes de programación) para gestionar el almacenamiento y la recuperación de la
información, y _scripts_ del lado de cliente (Javascript, CSS y HTML) para presentar la información al usuario. Esto
permite a los usuarios la interacción con el _backend_ por medio de formularios, sistemas de gestión de contenidos,
carritos de la compra, etc. Además de permitir la creación de documentos, la compartición de información, la
colaboración en proyectos y el trabajo en documentos compartidos independientemente de la localización y de los
dispositivos de los usuarios.

Las aplicaciones web encajan dentro de las aplicaciones cliente-servidor, que siguen un modelo de aplicación
distribuida. Se caracterizan por estar alojada en un servidor web en una URL determinada.

[[cliente_servidor]]
.Arquitectura cliente-servidor.
image::cliente-servidor.png[scaledwidth="50%"]

En este tipo de arquitecturas la entidad que realiza solicitudes se denomina cliente. Las características de un
cliente son:

* Es quien inicia una solicitud o petición a un servidor, por lo tanto asumen un rol activo en la comunicación.
* Se queda a la espera y recibe la respuesta del servidor.
* Se puede conectar con varios servidores a la vez por lo general.
* Suele utilizar una _interfaz gráfica de usuario_ como media de interacción con el servidor.

A la entidad receptora de dichas solicitudes se le denomina servidor, cuyas características se resumen a continuación:

* Están a la espera de solicitudes por parte de los clientes, por lo tanto asumen un rol pasivo en la comunicación.
* Reciben una solicitud, la procesa y, posteriormente, envía la respuesta al cliente.
* Por lo general, acepta un número elevado de conexiones por parte de diferentes clientes.

Las aplicaciones web poseen ventajas significativas con respecto a otro tipo de aplicaciones. Al ejecutarse en un
navegador web, proporcionan una gran compatibilidad entre plataformas (portabilidad) y deberían funcionar
independientemente de la versión del sistema operativo instalado en el cliente. Además no requieren que el usuario
realice actualizaciones, ya que estas son implementadas en el lado del servidor. Por último, este tipo de
aplicaciones requieren poco o nada de espacio libre en disco, suelen ser bastante livianas.

Sin embargo también tiene algunas desventajas que, como se verá, tiene solución relativamente sencilla. Requieren
navegadores web totalmente compatibles para funcionar, aunque normalmente esto se resuelve actualizando la versión de
los navegadores. En numerosas ocasiones requieren que exista una conexión a Internet, que si es interrumpida, puede
que la aplicación no funcione. Esto, dependiendo de la aplicación, se podría abordar implementando soluciones que
permitan el funcionamiento _off-line_.

Patrones de diseño
~~~~~~~~~~~~~~~~~~

Patrón _Singleton_
^^^^^^^^^^^^^^^^^^
El patrón _singleton_ es un patrón de diseño que restringe la instanciación de una clase a un único objeto y
proporciona un punto de acceso global a dicha instancia. Esto es útil cuando se necesita exactamente un objeto para
coordinar acciones en todo el sistema. El concepto a veces se generaliza a sistemas que operan más eficientemente
cuando sólo existe un objeto, o que restringen la instanciación a un cierto número de objetos. A continuación se
muestra el diagrama UML del patrón de diseño _Singleton_.

[[Singleton]]
.Patrón Singleton.
image::singleton.png[scaledwidth="30%"]

Cuando un componente requiere una dependencia, AngularJS lo resuelve utilizando el siguiente algoritmo:

. Coge su nombre y hace una búsqueda en un _hashmap_ que se define en un _closure_ léxico, por lo que tiene una
visibilidad privada.
. Si la dependencia existe, AngularJS los pasa como parámetro al componente que lo requiere.
. Si la dependencia no existe:
.. AngularJS lo instancia llamando al _factory method_ de su _provider_ (_i.e._ `$get`). Se debe tener en cuenta que
instanciar la dependencia puede requerir una llamada recursiva al mismo algoritmo para resolver todas las dependencias
requeridas por la dependencia dada. Este proceso puede llevar a una dependencia circular.
.. AngularJS lo cachea dentro del _hash map_ mencionado anteriormente.
.. AngularJS lo pasa como parámetro al componente que lo requiere.

Se puede observar mejor el código fuente de AngularJS, que implementa el método `getService`:

[source, python]
----
function getService(serviceName) {
  if (cache.hasOwnProperty(serviceName)) {
    if (cache[serviceName] === INSTANTIATING) {
      throw $injectorMinErr('cdep', 'Circular dependency found: {0}', path.join(' <- '));
    }
    return cache[serviceName];
  } else {
    try {
      path.unshift(serviceName);
      cache[serviceName] = INSTANTIATING;
      return cache[serviceName] = factory(serviceName);
    } catch (err) {
      if (cache[serviceName] === INSTANTIATING) {
        delete cache[serviceName];
      }
      throw err;
    } finally {
      path.shift();
    }
  }
}
----

Los _servicios_ y las _factorías_ en Angular son _singletons_, ya que no se instancian más de una vez. Se puede
considerar la memoria caché como un gestor de _singleton_. Existe una ligera variación con el diagrama mostrado
anteriormente ya que, en lugar de mantener la referencia privada estática al _singleton_ dentro de su constructor, se
mantiene dentro del gestor de _singleton_ (indicado en el _snippet_ anterior como `cache`).

Patrón Fachada
^^^^^^^^^^^^^^
El patrón fachada es un patrón estructural. Se utiliza cuando se necesita proporcionar una interfaz simple de alto
nivel para un subsistema complejo, o cuando se quiera estructurar varios subsistemas en capas, ya que las fachadas
serían el punto de entrada a cada nivel. Aplicando este patrón se reduce la complejidad, minimiza las
comunicaciones y dependencias entre subsistemas y desacopla un sistema de sus clientes, haciéndolo más
independiente, portable y reutilizable.

Es una buena práctica en AngularJS, y en el desarrollo de software en general, situar la lógica de negocio fuera de
los controladores, en servicios separados. Esto permite que el código sea mas sencillo de probar y proporciona
una manera más sencilla para el desarrollador de averiguar qué está sucediendo.

El patrón fachada se ha utilizado con frecuencia en este proyecto con el fin de mantener el código lo más limpio
posible y buscando una reutilización de las funcionalidades más utilizadas, como por ejemplo el acceso a cada una de
las partes de una guía clínica o para la interacción con el servidor. En el primer caso, cuando se ejecuta un método
del servicio _GuidelineFactory_, en numerosas ocasiones interactúa con otros servicios y controladores ejecutando
lógica de negocio que está oculta para el cliente que invocó dicho método. En el segundo caso se ha utilizado el patrón
fachada para ocultar los detalles de la implementación de comunicación con el servidor.

[[Facade]]
.Patrón fachada.
image::facade.png[scaledwidth="60%"]

En AngularJS se suelen utilizar con asiduidad las fachadas. Cada vez que se quiere proporcionar una API de alto nivel
a una funcionalidad dada se suele crear una fachada. Por ejemplo, a continuación se muestra cómo podemos hacer una
petición `XMLHttpRequest` POST:

[source, python]
----
var http = new XMLHttpRequest(),
    url = '/example/new',
    params = encodeURIComponent(data);
http.open("POST", url, true);

http.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
http.setRequestHeader("Content-length", params.length);
http.setRequestHeader("Connection", "close");

http.onreadystatechange = function () {
  if(http.readyState == 4 && http.status == 200) {
    alert(http.responseText);
  }
}
http.send(params);
----

Pero si se quiere hacer un POST de esos mismos datos usando el servicio `$http` de AngularJS, se puede hacer lo
siguiente:

[source, python]
----
$http({
  method: 'POST',
  url: '/example/new',
  data: data
})
.then(function (response) {
  alert(response);
});
----

o, incluso, se podría hacer de la siguiente manera:

[source, python]
----
$http.post('/someUrl', data)
.then(function (response) {
  alert(response);
});
----

La segunda opción proporciona una versión preconfigurada, la cual crea una petición HTTP a la URL dada. Incluso se ha
creado una mayor abstracción utilizando el servicio
`$resource` footnote:[https://docs.angularjs.org/api/ngResource/service/$resource], el cual se construye sobre el
servicio `$http`.

Patrón _Proxy_.
^^^^^^^^^^^^^^^
Un _proxy_, en su sentido más abstracto, es una clase que funciona como una interfaz de otra cosa. El _proxy_ podría
hacer de _interface_ a cualquier cosa: una conexión de red, un objeto grande en memoria, un archivo o algún otro
recurso que sea costoso o imposible de duplicar.

[[Proxy]]
.Patrón proxy.
image::proxy.png[scaledwidth="65%"]

Se pueden distinguir 3 tipos de _proxies_:

* Proxy virtual
* Proxy remoto
* Proxy protector

Se mencionará la implementación que AngularJS tiene del _proxy_ virtual. A continuación se muestra una llamada al
método `get` de la instancia `$resource`, llamada `User`:

[source, python]
----
var User = $resource('/users/:id'),
    user = User.get({ id: 42 });
console.log(user); //{}
----

En el _snippet_ anterior, `console.log` generaría un objeto vacío. Dado que la petición AJAX que tiene lugar por detrás,
cuando se invoca `User.get`, es asíncrona, no se tiene el usuario real cuando se llama a `console.log`. Justo después
de que `User.get` haga la petición GET, devuelve un objeto vacío y mantiene una referencia a él. Se puede pensar en
este objeto como _proxy_ virtual (un simple _placeholder_), que se rellenaría con los datos reales una vez que el
cliente reciba la respuesta del servidor. Esto en Angular funciona de la siguiente manera, consideremos el siguiente
_snippet_:

[source, python]
----
function MainCtrl($scope, $resource) {
  var User = $resource('/users/:id'),
  $scope.user = User.get({ id: 42 });
}
----

[source, html]
----
<span ng-bind="user.name"></span>
----

Cuando se ejecuta el código anterior, la propiedad `user` del objeto `$scope` tendrá un valor de un objeto vacío
(`{}`), lo que significa que `user.name` será indefinido y no se renderizará nada en la vista. Internamente AngularJS
mantendrá la referencia a este objeto vacío. Una vez que el servidor devuelva la respuesta de la petición GET,
AngularJS rellenará el objeto con los datos recibidos del servidor. Durante el siguiente bucle de `$digest`, AngularJS
detectará el cambio en `$scope.user`, lo que llevará a la actualización de la vista.

Inyección de dependencias
^^^^^^^^^^^^^^^^^^^^^^^^^
La Inyección de Dependencias (_DI_ por sus siglas en inglés) es un patrón de diseño de software que se ocupa de cómo
los componentes consiguen sus dependencias. AngularJS cuenta con un subsistema inyector que se encarga de crear
componentes, resolver sus dependencias y proporcionarlos a otros componentes según lo solicitado.

La _DI_ aparece continuamente en AngularJS. Puede utilizarse al definir componentes o al proporcionar bloques de
ejecución y configuración para un módulo (ver los métodos `run` y `config` de un módulo).

* Los componentes como servicios, directivas, filtros y animaciones se definen mediante una _factory method_
inyectable o mediante un constructor. A estos componentes se les puede inyectar un _service_ o un _value_ como
dependencias.

* Los controladores se definen mediante una función constructora, a la que se le puede inyectar cualquiera de los
componentes _service_ y _value_ como dependencias, pero también pueden proporcionarse con dependencias especiales
(`$scope`).

* El método `run` acepta una función como parámetro, a la que se le puede inyectar componentes _service_, _value_ y
_constant_ como dependencias. No se pueden inyectar _providers_ en los bloques de ejecución.

* El método `config` acepta una función como parámetro, a la que se le puede inyectar componentes _provider_ y
_constant_ como dependencias. No se pueden inyectar componentes _service_ o _value_ en la configuración.

Para una comprensión más en profundidad sobre _DI_, puede consultarse
http://en.wikipedia.org/wiki/Dependency_injection[Inyección de Dependencia]
en Wikipedia, o un excelente http://martinfowler.com/articles/injection.html[artículo] al respecto, de Martin Fowler.

[[testing]]
Pruebas
~~~~~~~
El software se prueba contra una _especificación_, la cual hace referencia a una descripción precisa y detallada de la
funcionalidad y a las restricciones que se quieren obtener de un sistema, pensadas para la comunicación a los
desarrolladores de lo que se requiere y sirve como base de un contrato. JavaScript es un lenguaje de tipos de
datos dinámicos que cuenta con gran poder de expresión, pero realmente se cuenta con muy pocas ayudas por parte
del compilador. Por esta razón, cualquier código escrito en JavaScript debe venir con un conjunto de tests que
prueben las principales funcionalidades. AngularJS ha sido diseñado enfocado a la las pruebas. Existen multitud de
herramientas para probar el código AngularJS.

Las pruebas unitarias, como su propio nombre indica, consisten en probar unidades funcionales individuales de código.
Tratan de responder preguntas del tipo ``¿se ha pensado en la lógica correctamente?'' o ``¿La función de ordenación
ordena la lista en el orden correcto?''

Para responder a este tipo de preguntas es muy importante que podamos aislar unidad funcional de código que se va a
probar. Esto se debe a que cuando se quiere probar la función de ordenación no queremos ser forzados a crear partes
relacionadas como los elementos DOM o hacer llamadas XHR para buscar los datos para ordenarlos.

AngularJS trata de hacer que sea fácil para el desarrollador hacer lo correcto. Para las solicitudes de XHR, se
proporciona inyección de dependencias para que estas solicitudes puedan ser simuladas. Para el DOM, este se abstrae,
para que se pueda probar el modelo sin tener que manipular el DOM directamente. Los tests podrían entonces asegurar
que los datos se han ordenado sin tener que crear u observar el estado del DOM o esperar a que cualquier solicitud de
XHR devuelva datos. La función de ordenación individual se puede probar de forma aislada.

AngularJS viene con inyección de dependencia incorporada, lo que hace que los componentes sean mucho más fáciles de
probar, ya que se pueden pasar las dependencias de un componente y hacer un _mock_ de los mimos como desee.

Los componentes que tienen sus dependencias inyectadas permiten que sean fácilmente simuladas en un test, sin tener
que ensuciar con cualquier variable global que podría afectar inadvertidamente otros tests. Para probar aplicaciones
Angular existen ciertas herramientas que deberían ser usadas que hacen que la fase de pruebas sea mucho mas sencilla
de configurar y ejecutar

Para probar las aplicaciones de AngularJS hay ciertas herramientas que debe usar que harán que las pruebas sean mucho
más fáciles de configurar y ejecutar. A continuación se verán el _framework_ de pruebas Jasmine, los _test runners_
_Karma_ y _Protractor_.

Jasmine Framework
^^^^^^^^^^^^^^^^^
Jasmine es un _framework_ de desarrollo https://en.wikipedia.org/wiki/Behavior-driven_development[dirigido por
comportamiento] para probar código JavaScript. No depende de ningún otro framework de JavaScript, ni de un DOM. Y
tiene una sintaxis clara y obvia para que los tests se puedan escribir fácilmente.

Antes de empezar a escribir el código, teniendo en cuenta la especificación formal de requisitos, se debe saber cómo
se tiene que comportar el sistema. Se pueden escribir estas especificaciones en el código, en Angular, por
convención, a cada fichero de test se le llama igual que el fichero que contiene la funcionalidad que se quiere
probar, pero añadiéndole `.spec.js` al final. Cuando se ejecutan las pruebas se obtiene un éxito (si todo funciona
según la especificación) o un error (si no lo hace). Si se obtiene un éxito para todos los test, se puede garantizar
que el sistema funciona conforma a la especificación, de lo contrario se sabe qué funcionalidades están fallando y
que el sistema no está funcionando como se espera.

Las pruebas son útiles por varios motivos. Primero, pueden evaluar la corrección de un programa después
de un cambio. Un ejemplo podría ser aquel en el que todas las pruebas pasan y, posteriormente, se decide que se
quiere realizar una mejora para que un método sea más rápido. Se pueden hacer los cambios y observar que dicho método
efectivamente es más rápido, pero si en la siguiente ejecución de las pruebas se observa que algunos tests están
fallando, se descubre rápidamente que el cambio ha roto parte del código. Las pruebas automatizadas permiten ver
esos errores antes de que sucedan en el ``mundo real''. Estas pruebas también sirven como buenos ejemplos para otros
desarrolladores. Si un desarrollador está tratando de averiguar cómo usar alguna parte indocumentada del código, una
prueba bien escrita puede ayudarle a ver cómo funciona dicha parte.

Hay muchas herramientas que ayudan a la automatización de este tipos de pruebas, _Jasmine_ es una de ellas. A
continuación se muestra un ejemplo de un test básico que explica los fundamentos básicos de este _framework_, se
muestra en el siguiente fragmento la definición del test usando _Jasmine_.

[source, python]
----
describe("Hello world", function() {                <1>
  it("says hello", function() {                     <2>
    expect(holaMundo()).toEqual("¡Hola mundo!");    <3>
  });
});
----

<1> Bloque _describe_: define una _suite_. Básicamente, se trata de un componente de la aplicación.
<2> Bloque _it_.: define un _spec_. Cada una de las funcionalidades que se quieren probar.
<3> Bloque _expect_: funcionalidad a testear.

En el ejemplo anterior se está comprobando si `holaMundo()` realmente devuelve el valor esperado ``¡Hola mundo!''.
Esta comprobación se denomina _matcher_. Jasmine incluye gran cantidad de _matchers_ predefinidosfootnote:[Para la
versión 2.4.1 de _Jasmine_, que es la utilizada en este proyecto, se incluyen de forma nativa los siguientes
_matchers_: https://jasmine.github.io/2.4/introduction], aunque el usuario puede definir los suyos propios.

Pruebas unitarias con _Karma_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_Karma_ es una herramienta que permite ejecutar código fuente, _i.e._ JavaScript, en navegadores reales. El hecho
de que se ejecute contra navegadores reales en lugar de navegadores simulados, con un DOM virtual, lo hace muy potente.
Las implementaciones de DOM varían entre los diferentes navegadores, por lo tanto la idea de _Karma_ es utilizar los
navegadores reales para la realización de las pruebas unitarias de una forma más real y para asegurarse de que la
aplicación funcione correctamente en todos los navegadores que necesite soportar. _Karma_ se ejecuta en la línea de
comandos y mostrará los resultados de sus pruebas en la línea de comandos una vez que se hayan ejecutado en el
navegador.

Entre otras funcionalidades, Karma permite:

* Hacer pruebas de código en navegadores reales.
* Hacer pruebas de código en diferentes tipos de navegadores (escritorio, móviles, tablets, etc.).
* Ejecutar las pruebas en local durante el desarrollo.
* Ejecutar las pruebas en un servidor de integración continua, como se ha hecho en este proyecto, usando
https://travis-ci.org/[Travis CI] y https://github.com/[GitHub].
* Ejecutar las pruebas cada vez que se guarde un fichero.
* Hacer la vida más cómoda a los desarrolladores que realizan las pruebas.
* Utilizar https://github.com/gotwarlost/istanbul[Estambul] para la generación automática de informes.
* Utilizar http://requirejs.org/[RequireJS] para la gestión de los ficheros de la aplicación.

_Karma_ no es un _framework_ de pruebas, ni una librería de aserciones. _Karma_ es un _test runner_, simplemente lanza
un servidor HTTP, y genera el fichero HTML a ser utilizado por el _framework_ de pruebas que se quiera utilizar,
entre ellos https://github.com/karma-runner/karma-jasmine[Jasmine],
https://github.com/karma-runner/karma-mocha[Mocha], https://github.com/karma-runner/karma-qunit[QUnit], y
https://www.npmjs.org/browse/keyword/karma-adapter[muchos otros]. _Karma_ soporta la mayoría de navegadores
disponiblesfootnote:[Navegadores soportados por _Karma_: https://karma-runner.github.io/latest/config/browsers.html].
Las instrucciones completas de instalaciónfootnote:[Documentación sobre la instalación de _Karma_:
https://karma-runner.github.io/latest/intro/installation.html] y configuraciónfootnote:[Documentación sobre la
configuración de _Karma_: https://karma-runner.github.io/latest/intro/configuration.html]
estás disponibles en la página web oficial de _Karma_.

Pruebas end-to-end con _Protractor_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
A medida que las aplicaciones crecen en tamaño y complejidad, se vuelve poco realista confiar en las pruebas hechas a
mano para verificar la corrección de nuevas funcionalidades y detectar errores. Las pruebas unitarias son la primera
línea de defensa para la detección de errores, pero a veces los problemas surgen con la integración entre los
componentes y no pueden ser detectados en las pruebas unitarias. Es necesario, entonces, la realización de las
pruebas de extremo a extremo para detectar este tipo de problemas.

Protractor es un _testrunner_ de pruebas _end-to-end_ que simula las interacciones del usuario que ayudan a verificar
la salud de una aplicación AngularJS.

Protractor es una aplicación Node.js y ejecuta pruebas end-to-end escritas en JavaScript y se ejecutan en Node.
Utiliza https://code.google.com/p/selenium/wiki/GettingStarted[WebDriver] para controlar los navegadores y simular
las acciones de los usuarios.

Protractor utiliza Jasmine como su sintaxis para las pruebas. Al igual que en las pruebas unitarias, un archivo de
pruebas consta de uno o más bloques `it` que describen las funcionalidades que se quieren probar de la aplicación
aplicación. Los bloques `it` se componen de _commands_ y _expectations_. Los _commands_ le indican a Protractor
realice alguna acción con la aplicación, como navegar a una página o hacer clic en un botón. Las _expectations_ le
indican que verifique algo sobre el estado de la aplicación, _e.g._ el valor de un campo o la URL actual.

Si alguna expectativa dentro de un bloque `it` falla, el _testrunner_ lo marca como fallido y continúa con el
siguiente bloque.

Los archivos de test también pueden tener bloques `beforeEach` y `afterEach`, que se ejecutarán antes o después de
cada bloque `it`, independientemente de si el bloque pasa o falla.

protractor]]
.Bloques en un fichero de pruebas _Protractor_.
image::sequence-editBinding.png[scaledwidth="60%"]

Además de los elementos anteriores, las pruebas también pueden contener funciones auxiliares para evitar la duplicidad de código en los bloques. A continuación se muestra un ejemplo simple de pruebas con _Protractor_:

[source, python]
----
describe('La lista de tareas', function() {
  it('debería filtrar resultados', function() {
    // Buscar el elemento ng-model="usuario" e introducir "froome" en él
    element(by.model('usuario')).sendKeys('froome');
    // Buscar el primer (y único) botón de la página y hacer clic sobre él
    element(by.css(':button')).click();
    // Verificar que hay 10 tareas
    expect(element.all(by.repeater('tarea in tareas')).count()).toEqual(10);
    // Introducir 'bicicletas' en el elemento con ng-model="filterText"
    element(by.model('filterText')).sendKeys('bicicletas');
    // Verificar que ahora sólo existe un elemento en la lista de tareas
    expect(element.all(by.repeater('tarea in tareas')).count()).toEqual(1);
  });
});
----
Este ejemplo describe los requisitos de una lista de tareas, en forma de especificaciones, que debería ser capaz de
filtrar una lista de elementos.

Node.js
~~~~~~~
Node.js es un entorno de ejecución multiplataforma, de código abierto, para JavaScript construido con el motor de
JavaScript V8 de Chrome <<NODE17>>. Node.js usa un modelo de operaciones E/S sin bloqueo y orientado a eventos, que lo
hace liviano y eficiente. El ecosistema de paquetes de Node.js, _npm_, es el ecosistema más grande de librerías de
código abierto en el mundo en estos momentos.

Para bien o para mal, JavaScript es el lenguaje de programación más popular para la Web y, debido al alcance de esta,
JavaScript ha cumplido con el sueño de ``escribir una vez, ejecutar en cualquier parte'' que tenía Java en la década de
los noventa.

Desde el lanzamiento de Google Chrome a finales de 2008, el rendimiento de JavaScript ha mejorado a un ritmo
increíblemente rápido debido<<CANT04>> a la fuerte competencia entre los proveedores de navegadores (Mozilla,
Microsoft, Apple, Opera y Google). El rendimiento de estas modernas máquinas virtuales JavaScript literalmente está
cambiando los tipos de aplicaciones que puede crear en la webfootnote:[Ver la página _Chrome Experiments_ para ver
algunos ejemplos: http://www.chromeexperiments.com/.]. Un ejemplo convincente y francamente alucinante de esto es
jslinuxfootnote:[Jslinux, un emulador JavaScript para PC: http://bellard.org/jslinux/.], un emulador de PC que se
ejecuta en JavaScript donde puede cargar un kernel de Linux, interactuar con la sesión de terminal y compilar un
programa C, todo en su navegador.

Node usa V8, la máquina virtual que utiliza Google Chrome, para la programación del lado del servidor. V8 da a Node un
gran impulso en el rendimiento, ya que elimina a los intermediarios, prefiriendo la compilación directa a código nativo
sobre la ejecución de _bytecode_ o el uso de un intérprete. Dado que Node utiliza JavaScript en el servidor, también
hay otros beneficios:

* Los desarrolladores pueden escribir aplicaciones web en un solo lenguaje, lo que ayuda al reducir el cambio de
contexto entre el desarrollo del cliente y del servidor y permitir el intercambio de código entre ambos,
reutilizar el mismo código para la validación de formularios o cualquier lógica de negocio.
* JSON es un formato de intercambio de datos muy popular hoy en día y es nativo de JavaScript.
* JavaScript es el lenguaje utilizado en varias bases de datos NoSQL (como CouchDB y MongoDB), por lo que la
integración con ellos se realiza de forma natural (por ejemplo, el shell y el lenguaje de consulta de MongoDB es
JavaScript, el paradigma _map/reduce_ de CouchDB es JavaScript).
* JavaScript es un lenguaje _target_, en el sentido de que ya hay una serie de lenguajes que se compilar a
Javascriptfootnote:[Ver la _Lista de lenguajes que se compilan a JavaScript_: https://github.com/jashkenas/coffee-script/wiki/List-of-languages-that-compile-to-JS.].
* Node usa una máquina virtual (V8) que se mantiene actualizada con el estándar ECMAScriptfootnote:[Para más
información sobre el estándar ECMAScript, ver Wikipedia: http://en.wikipedia.org/wiki/ECMAScript]. En otras
palabras, no se tiene que esperar a que todos los navegadores se pongan al día para usar las nuevas características
de lenguaje JavaScript en Node.js.

¿Quién diría que JavaScript terminaría siendo un lenguaje convincente para escribir aplicaciones del lado del servidor?
Sin embargo, debido a su alcance, rendimiento y otras características mencionadas anteriormente, Node ha ganado mucho
terreno. Aunque JavaScript es sólo una pieza del rompecabezas, la manera en la que Node utiliza JavaScript es
aún más convincente.

AngularJS y patrón de arquitectura Model-View-Controller
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
AngularJS es un framework basado en JavaScript de código abierto, mantenido por Google y por una
amplia comunidad de individuos y organizaciones para la solución de muchos de los desafíos encontrados en el
desarrollo de _aplicaciones web de una sola página_. Lo que se pretende con este framework es simplificar el
desarrollo y las pruebas de este tipo de aplicaciones proporcionando un framework Model-View-Controller (MVC) y
Model-View-Viewmodel (MVVM) para las arquitecturas del lado cliente.

La principal idea detrás del patrón MVC es que se tiene una separación clara en el código entre la gestión de los
datos (modelo), la lógica de la aplicación (controlador) y la presentación de datos al usuario (vista). Las
aplicaciones MVC surgieron ya en los años 70 de la mano de Smalltalk. A partir de entonces se fueron convirtiendo
cada vez más populares en casi todos los entornos de desarrollo donde estuvieran involucradas las interfaces de
usuario. Hasta hace relativamente poco tiempo, era prácticamente ajeno al desarrollo web.

[[mvc]]
.Patrón Model-View-Controller.
image::mvc.png[scaledwidth="40%"]

En este patrón de arquitectura, la vista obtiene los datos del modelo para ser mostrados al usuario. Cuando un
usuario interactúa con la aplicación haciendo clic con el ratón o escribiendo un _input_, el controlador responde
cambiando los datos en el modelo Finalmente, el modelo notifica a la vista que se ha producido un cambio para que
pueda actualizar lo que se está mostrando. En las aplicaciones Angular, la vista es el <<X2, Document Object Model>>
(DOM)footnote:[Especificación técnica de w3c: https://www.w3.org/DOM/DOMTR], los controladores son clases
JavaScript y los datos del modelo se almacenan en propiedades de objetos. MVC es apropiado por varios motivos.. En
primer lugar ofrece un modelo mental que indica dónde colocar las cosas, de tal manera que no hay que reinventar la
rueda continuamente. Los colegas que colaboran en un mismo proyecto tendrán una ventaja de antemano al entender lo
que ya se hubiese escrito, ya que ellos sabrán que se está utilizando la estructura MVC para organizar el código. Y
quizás lo que es más importante, ofrece grandes beneficios ya que hace que las aplicaciones sean más fáciles de
extender, mantener y probar.

Módulos en AngularJS
^^^^^^^^^^^^^^^^^^^^
Un _módulo_<<MODU17>> en AngularJS es un contenedor para las diferentes partes de una aplicación, como controladores,
servicios, filtros, directivas, información sobre configuración, etc. Es una manera de agrupar funcionalidades. La
mayoría de aplicaciones en otros lenguajes de programación como Java o incluso Python tienen un método _main_ que
instancia y vincula todas las partes de la aplicación. Las aplicaciones Angular no tienen dicho método. En vez de
ello, tiene el concepto de módulos, que especifican de forma declarativa las dependencias de la aplicación y cómo
esta debe ser inicializada. Esta aproximación tiene varias ventajas:

* El proceso es declarativo. Esto significa que está escrito de tal manera es que más sencillo de escribir y de
entender.
* Es modular. Ello fuerza a que se piense en cómo se van a definir los componentes y dependencias de la aplicación. Se
puede empaquetar código como módulos reutilizables.
* Dichos módulos pueden ser cargados en cualquier orden--incluso en paralelo--ya que los módulos pueden diferir la
ejecución.
* Facilitan las pruebas, ya que los tests unitarios sólo tienen que cargar los módulos necesarios, lo cual hace que
dichos tests sean muy rápidos.
* Los tests _end-to-end_ pueden usar módulos para sobreescribir la configuración.

En AngularJS un módulo se declara de una manera muy sencilla.

[source, python]
----------------------------------------------------
// declare a module
var myAppModule = angular.module('myApp', []);

// configure the module.
// in this example we will create a greeting filter
myAppModule.filter('greet', function() {
 return function(name) {
    return 'Hello, ' + name + '!';
  };
});
----------------------------------------------------

Dicho módulo se utilizaría en la vista declarándolo con la _directiva_ `ng-app`. Esta _directiva_ le dice a Angular que
inicie la aplicación usando el módulo _myApp_.

[source, html]
-------------------------
<div ng-app="myApp">
  <div>
    {{ 'World' | greet }}
  </div>
</div>
-------------------------

Estos módulos se deben de definir de una manera organizada. Es recomendable tener módulos separados para los
controladores, servicios, filtros, directivas, etc. Para el desarrollo de esta aplicación se ha tenido en cuenta una
https://github.com/johnpapa/angular-styleguide/tree/master/a1[guía de buenas prácticas] muy utilizada en la comunidad
de desarrollo de AngularJS. Em módulo principal podría entonces simplemente declarar el resto de módulos como
dependencias, tal como se ha hecho en el desarrollo de esta aplicación. Esto hace que sea más sencilla la gestión de
nuestros módulos, ya que se convierten en piezas aisladas de código, teniendo cada uno de ellos una, y sólo una
responsabilidad. Esto también permite que los tests carguen el módulo (o módulos) que interesen, haciendo que sean
más rápidos y que se focalicen en la funcionalidad a ser probada.

Plantillas
^^^^^^^^^^
Las _aplicaciones web multi-página_ generan su HTML ensamblándolo y uniéndolo con datos del servidor y, una vez hecho
esto, se envían las páginas al navegador. Muchas _aplicaciones web de una sola página_ también hacen esto de alguna
manera. Angular es diferente en este sentido ya que la plantilla (el HTML) y los datos se envían al navegador para
ser ensamblados allí. El servidor sólo sirve recursos estáticos: las plantillas y los datos requeridos por dichas
plantillas para que se puedan mostrar de forma apropiada. Una vez recibida la plantilla en el navegador web, Angular
expande dichas plantillas en la aplicación poblando la plantilla con los datos pertinentes.

El flujo básico de este procedimiento es el siguiente:

. Un usuario pide la primera página de la aplicación.
. El navegador del usuario hace una conexión HTTP al servidor y carga la página `index.html` que contiene la plantilla.
. Angular se carga en la página, espera a que la página esté totalmente cargada y busca una directiva `ng-app` para
definir su alcance.
. Angular recorre la plantilla buscando directivas y vinculaciones (two-way databinding). El resultado de este
proceso es que se registran los _listeners_ y se hacen las manipulaciones del DOM necesarias, además de la recuperación
de los datos iniciales desde el servidor. El resultado final es que se inicializa la aplicación y la plantilla se
convierte en una vista como un DOM.
. A partir de este punto, el usuario se conectará con el servidor para cargar la información adicional necesaria a
medida que la vaya requiriendo el usuario.

Estructurar una aplicación con Angular permite que las plantillas se mantengan separadas de los datos que las
pueblan, por lo tanto las plantillas son cacheables. Después de la primera carga, sólo se necesita que se envíen los
nuevos datos del servidor al cliente, con lo que resulta en un mejor rendimiento de la aplicación.

Controladores
^^^^^^^^^^^^^
Los controladores, en AngularJS, son objetos que permiten desarrollar la lógica de negocio de la aplicación. Enlazan
el ámbito `$scope` con la vista y permite tener un control total de los datos. Este enlace con la vista se realiza a
través de una directiva `ng-controller`. Un módulo necesita como mínimo un
controlador para funcionar. Un controlador es una parte
funcional de un módulo, con
 sus propios atributos, modelos y métodos. Para declarar un controlador se utiliza el método `controller()` del
 objeto `module` visto anteriormente. Este método acepta, como mínimo, un parámetro llamado `$scope`, que representa
 el alcance de variables, modelos y métodos del controlador.

[source, python]
----------------------------------------------------
var app = angular.module("MyApp", []);
app.controller("mainController", function($scope) {
   // contenido del controlador
});
----------------------------------------------------

Tanto el método `angular.module()` como el método `controller()` devuelven una referencial al módulo, es posible
concatenar métodos. Como se puede observar, en el _snippet_ anterior, declarar un controlador es bastante sencillo, tan
solo basta con asignarle un nombre e inyectar las dependencias necesarias, podemos inyectar otros componentes dentro
del controlador, sean nativos de AngularJS u otros componentes creados por nosotros.

Angular hace uso intensivo de la inyección de dependencias en todos sus componentes, para inyectar nuevas
dependencias simplemente se le pasan como parámetros al controlador separados por comas.

[source, python]
----------------------------------------------------------------------
app.controller('mainController', function($scope, servicio, factoria) {
   //contenido
});
----------------------------------------------------------------------

Tal como se ha comentado anteriormente, en la vista se usa la directiva `ng-controller` para asociar el controlador
definido a la vista. El controlador debemos añadirlo en el nivel de anidamiento adecuado en el cual se quiere que
tenga alcance.

[source, html]
-------------------------
<body>
   <div ng-controller="mainController">
      <h1>Hola AngularJS</h1>
   <div/>
</body>
-------------------------

Dentro del alcance donde se haya declarado el controlador se tiene un objeto `$scope` que permite controlar los datos.
A continuación se muestra un sencillo ejemplo de cómo se pueden mostrar los datos del controlador en la vista.

[source, python]
---------------------------------------------------
app.controller('mainController', function($scope) {
   $scope.saludo = "AngularJS";
});
---------------------------------------------------

[source, html]
-------------------------
<body>
   <div ng-controller="mainController">
      <h1>Hola {{saludo}}</h1>
   <div/>
</body>
-------------------------

Se puede observar como en el controlador se ha creado la variable `saludo` dentro del `$scope`, al cual se le ha
asignado un valor. Por otra parte en la vista podemos ver cómo se accede y se muestra la variable. Para hacer
referencia a las variables del `$scope` se utiliza el _double_curly_ ``{{}}'' que trae incorporado Angular en su propio
motor de plantillas.

En resumen, se puede decir que los módulos y controladores en AngularJS son componentes que nos permiten desacoplar el
código, englobar funcionalidades y tener un código más limpio. Los controladores extienden o construyen el `$scope`,
el cual se encarga de contener los datos y de transferirlos de la vista al controlador y viceversa.

Directivas
^^^^^^^^^^
Las directivas<<DIRE17>> son, desde un punto de vista de alto nivel, _marcadores_ en un elemento del DOM (_i.e._
un atributo, un nombre de elemento, un comentario o una clase CSS) que le informan al compilador de Angular
(`$compile`) que vincule un comportamiento especial a dicho elemento del DOM (_e.g._ a través de escuchadores de
eventos), o incluso que transforme el elemento del DOM y sus elementos hijos.

Angular vienen incorporado con un conjunto de directivas, como `ngBind`, `ngModel` o `ngClass`. Del mismo modo que
es posible crear controladores o servicios propios, también se pueden crear directivas. Cuando AngularJS inicializa
una aplicación, el compilador HTML recorre el DOM emparejando directivas con elementos del DOM.

Para poder crear directivas es importante saber cómo el compilador de AngularJS determina cuándo usar una directiva.
Similar a la terminología usada cuando un https://developer.mozilla.org/en-US/docs/Web/API/Element.matches[elemento
*se corresponde con* un selector], se puede decir que un elemento *se corresponde con* una directiva cuando la
directiva es parte de su declaración. En el siguiente ejemplo se puede decir que el elemento `<input>` se corresponde
con la directiva `ngModel`.

[source, html]
-------------------------
<input ng-model="foo">
-------------------------

El elemento `<input>` de a continuación también encaja con `ngModel`.

[source, html]
-------------------------
<input data-ng-model="foo">
-------------------------

Y el siguiente elemento `<person>` se corresponde con la directiva `person`.

[source, html]
-------------------------
<person>{{name}}</person>
-------------------------

.Normalización.
AngularJS normaliza el _tag_ de un elemento y los nombres de atributos para determinar qué elementos
encajan con qué
directivas. En terminología AngularJS, se suele hacer referencia a las directivas por su nombre normalizado usando
notación _camelCase_ (_e.g._ `ngModel`). Sin embargo, ya que HTML no es _case-sensitive_, se suele
hacer referencia a las directivas en el DOM usando notación _lower-case_, normalmente usando atributos
https://en.wikipedia.org/wiki/Letter_case#Special_case_styles[_dash-delimited_] en los elementos del DOM (_e.g._
`ng-model`). El proceso de normalización es el siguiente:

. Eliminar `x-` y `data-` del inicio de los elementos/atributos.
. Convertir el `:`, `-` o los nombres delimitados por `_` a _camelCalse_.

Por ejemplo, las siguientes formas son equivalentes y todas ellas se corresponden con la directiva `ngBind`.

[source, html]
-------------------------
<div ng-controller="Controller">
  Hello <input ng-model='name'> <hr/>
  <span ng-bind="name"></span> <br/>
  <span ng:bind="name"></span> <br/>
  <span ng_bind="name"></span> <br/>
  <span data-ng-bind="name"></span> <br/>
  <span x-ng-bind="name"></span> <br/>
</div>
-------------------------

.Tipos de directivas.
`$compile` puede emparejar directivas basadas en nombres de elementos (E), atributos (A),
nombres de clases \(C) y comentarios (M). Las directivas nativas de Angular muestran en su documentación qué tipo de
emparejamiento soportan. A continuación se muestran las diferentes maneras en las que una directiva (`myDir` en este
caso) que cumple los cuatro tipos mencionados puede ser referenciada desde una plantilla. Una directiva puede
especificar qué tipos soporta en su propiedad `restrict` de su definición. Si no se indica ninguno, por defecto
soporta los tipos `EA`.

[source, html]
-------------------------
<my-dir></my-dir>
<span my-dir="exp"></span>
<!-- directive: my-dir exp -->
<span class="my-dir: exp;"></span>
-------------------------

.Crear directivas propias.
Al igual que los controladores, las directivas se registran en los módulos. Para registrar
un directiva se usa la APU `module.directive`, que recibe el nombre de la directiva normalizada seguida de una
_función factoría_. Esta _función factoría_ debería de devolver un objeto con las opciones que le digan a `$compile`
cómo se debería de comportar la directiva cuando esté activa. La _función factoría_ se invoca sólo una vez cuando el
compilador encuentra la directiva por primera vez. Se puede realizar cualquier trabajo de inicialización en este
momento. La función se invoca usando https://docs.angularjs.org/api/auto/service/$injector#invoke[$injector.invoke]
lo cual la hace inyectable como si de un controlador se tratase. De manera análoga a la declaración de un
controlador, una directiva se declara de la siguiente manera:

[source, python]
---------------------------------------------------
var app = angular.module("myApp", []);
app.directive("myDirective", function() {
    return {
        template : "<h1>Made by a directive!</h1>"
    };
});
---------------------------------------------------

Tal como se ha descrito con anterioridad, una vez creada la directiva se puede invocar mediante el nombre de un
elemento, a través de un atributo, usando una clase y mediante un comentario. Los siguientes 4 _snippets_ producirían
el mismo resultado.

Nombre de un elemento:
[source, html]
----
<my-directive></my-directive>
----

Atributo:
[source, html]
----
<div my-directive></div>
----

Clase:
[source, html]
----
<div class="my-directive"></div>
----

Comentario:
[source, html]
----
<!-- directive: my-directive -->
----

Objeto `$scope` de AngularJS
^^^^^^^^^^^^^^^^^^^^^^^^^^^^
El objeto https://docs.angularjs.org/api/ng/type/$rootScope.Scope[scope] es un objeto que hace referencia al modelo
de la aplicación. Se trata de un contexto de ejecución para https://docs.angularjs.org/guide/expression[expresiones].
Tienen una estructura jerarquizada que imita a la estructura del DOM de la aplicación. Los _scopes_ pueden
observar expresiones y propagar eventos.

.Características del scope.
Los _scopes_ proporcionan APIs (https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$watch[`$watch`]) para
observar cambios en el modelo. También proporcionan APIs (https://docs.angularjs.org/api/ng/type/$rootScope
.Scope#$apply[`$apply`]) para propagar cualquier cambio en el modelo de la aplicación en la vista desde fuera del
ámbito de AngularJS (controladores, servicios, controladores de eventos de Angulars, etc.).

Los _scopes_ se pueden anidar para limitar el acceso a las propiedades de los componentes de la aplicación mientras
se proporciona acceso a propiedades compartidas del modelo. Los _scopes_ anidados son o bien ``_scopes_ hijos'' o
``_scopes_ a aislados''. Los primeros heredan las propiedades de su _scope_ padre mientras que los segundos no lo hacen.
Los _scopes_ proporcionan un contexto contra el que se evalúan las expresiones (_i.e._ la expresión `{{username}}` no
tiene ningún significado a no ser que se evalúe contra in _scope_ específico donde se defina el valor de la
propiedad `username`).

.El _scope_ como modelo de datos.
El _scope_ es el nexo de unión entre el controlador y la vista de la aplicación. Durante la fase de https://docs.angularjs.org/guide/compiler[linkado]
las directivas establecen expresiones `$watch` en el _scope_. El `$watch` permite que las directivas sean notificadas
cuando se produce algún cambio en una propiedad, lo que permite a la directiva renderizar el valor actualizado en el
DOM. Tanto los controladores como las directivas hacen referencias al _scope_, pero no entre ellas. Este acuerdo
aísla el controlador de la directiva y del DOM.

Two-way databinding
^^^^^^^^^^^^^^^^^^^
La vinculación de datos <<DATA17>> en las aplicaciones AngularJS es la sincronización automática de datos entre los
componentes del modelo y de la vista. La forma en que AngularJS implementa la vinculación de datos permite tratar
el modelo como la única fuente de datos en la aplicación. La vista es una proyección del modelo en todo momento.
Cuando el modelo cambia, la vista refleja dicho cambio y viceversa.

._Databinding_ en sistemas de plantillas clásicos.
La mayoría de los sistemas de plantillas enlazan datos en una sola dirección: incorporan los componentes de plantilla y
de modelo juntos en una vista. Después de que se produzca esta fusión, los cambios del modelo o de las secciones
relacionadas de la vista no se reflejan automáticamente en la vista. Peor aún, los cambios que el usuario hace a la
vista no se reflejan en el modelo. Esto significa que el desarrollador tiene que escribir código que sincroniza
constantemente la vista con el modelo y el modelo con la vista.

[[One_Way_Data_Binding]]
.One Way Data Binding.
image::One_Way_Data_Binding.png[scaledwidth="50%"]

._Databinding_ en el sistema de plantillas de AngularJS.
Las plantillas de AngularJS funcionan de manera diferente. En primer lugar, la plantilla (que es el HTML sin compilar
junto con cualquier marcado adicional o directivas) se compila en el navegador. El proceso de compilación produce una
vista en vivo. Cualquier cambio en la vista se refleja inmediatamente en el modelo y cualquier cambio en el modelo se
propaga a la vista. El modelo es una representación fiel de los datos para el estado de aplicación, simplificando
enormemente el modelo de programación para el desarrollador. Se puede pensar en la vista como una simple
proyección instantánea del modelo.

Debido a que la vista es sólo una proyección del modelo, el controlador está completamente separado de la vista y no
tiene conocimiento de ello. Esto hace que la prueba sea un complemento porque es fácil probar su controlador de forma
aislada sin la vista y la dependencia DOM / navegador relacionada.

[[Two_Way_Data_Binding]]
.Two Way Data Binding.
image::Two_Way_Data_Binding.png[scaledwidth="50%"]

Estándares de interoperabilidad
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Hoy en día los ciudadanos, por motivos profesionales, de ocio o de cualquier otra índole, estamos viajando
constantemente. Cuando viajamos lo hacemos, entre otras cosas, con la información necesaria para realizar
transacciones económicas entre diferentes sistemas bancarios, para la realización de una reserva de un viaje
utilizando sistemas de reservas de viajes o para la comunicación a través del teléfono móvil usando los sistemas de
telefonía móvil. De esta manera queda reflejado cómo en otros ámbitos sí existe una interoperabilidad entre sistemas.

Sin embargo, en el ámbito sanitario no es así. Actualmente existe una clara necesidad en nuestra sociedad de que
nuestra información sanitaria pueda también viajar con nosotros para que esté disponible dónde y cuándo la
necesitemos. Para todas aquellas actividades en las que la información tenga que comunicarse entre organizaciones se
necesita un estándar que permita la interoperabilidad en todo el proceso. Tener esta información disponible de una
manera normalizada no sólo es favorable para la asistencia continuada del paciente, sino que dicha información puede
ser utilizada para la investigación y la estadística, proporcionando un impacto positivo en la Medicina en general.

La interoperabilidadfootnote:[Definición de interoperabilidad según la _Wikipedia_: https://es.wikipedia.org/wiki/Interoperabilidad]
es la habilidad de dos o más sistemas o componentes para intercambiar información y utilizar la información
intercambiada. Hoy en día, en el ámbito sanitario prácticamente todos los sistemas reclaman para sí la
característica de que sean interoperables<<MUNO13>>, pero se podría decir que casi ninguno la cumple en la práctica.
Hay profesionales, tanto sanitarios como técnicos, que piensan que sus sistemas son semánticamente interoperables
porque utilizan terminologías clínicas, como SNOMED CT, o un determinado estándar; pero tampoco es así, pues éstos son
requisitos necesarios pero no suficientes, ya que la transferencia de información clínica que se busca con la
interoperabilidad semántica es algo más que la comunicación de palabras sueltas.

Para los sistemas sanitarios no es suficiente que los sistemas implicados puedan transferirse información, se debe ir
más allá. Se diferencian varios tipos de interoperabilidad:

* Interoperabilidad técnica: define la conexión entre los sistemas permitiendo que las entidades que forman parte de la
comunicación puedan llevar a cabo dicha conexión usando estándares y protocolos como 802.11, TCP/IP, HTTP, etc.
Este tipo de interoperabilidad es  la que permite el envío de información físicamente--en forma de bytes--entre
sistemas, la cual obviamente está muy avanzada ya que no es exclusiva de los sistemas sanitarios.
* Interoperabilidad sintáctica: es la que permite la comunicación de mensajes o documentos garantizando la recepción
adecuada de los mismos. Ejemplos de normas que pertenecen a este tipo de interoperabilidad son XML, la ISO
21090footnote:[ISO 21090: especificación de tipos de datos para entornos sanitarios.], modelos de referencia de
__open__EHR e UNE-EN ISO 13606, etc.
* Interoperabilidad semántica: es la interoperabilidad buscada en prácticamente todos los sistemas sanitarios. Se da
cuando un sistema acepta información de otro y puede hacer uso de dicha información, sin intervención humana,
manteniendo el significado que se le ha dado en origen. Este tipo de interoperabilidad es la que va a permitir la
deseada continuidad asistencial del ciudadano.
* Interoperabilidad organizativa: se sostiene en las reglas de negocio de las organizaciones. Para que dos
instituciones puedan cooperar deben compartir un contexto común en sus procedimientos y flujos de trabajo. En muchos
casos estas reglas dependen de las políticas de salud definidos por las administraciones.

No existen unos límites claros en dónde termina un tipo de interoperabilidad y dónde comienza el siguiente, pero se
podría hacer una aproximación representando los diferentes niveles según los cinco puntos que define el modelo de
referencia OSI para los sistemas distribuidos (técnico, ingeniería, computación, información y negocio) vinculados
con cada tipo de interoperabilidad de los que se acaban de definir.

[[interoperability-types]]
.Tipos de interoperabilidad.
image::interoperability-types[scaledwidth="50%"]

La gestión del conocimiento semántico es tratado en los puntos de vista _Información_ y _Computación_, son los que
van a posibilitar la interoperabilidad semántica y, por lo tanto, que ambos sistemas puedan intercambiarse
información manteniendo el significado que se le hubiese dado en origen y hacer uso de la misma sin intervención humana.

Como ya se ha adelantado en la <<_introduccion>>, los estándares de normalización recientes presentan un modelo
de datos dual centrado en el paciente, en el que se tiene consideración de la constante evolución del conocimiento
médico. Esto lo consigue manteniendo separada la _información_ en los sistemas, que es estática, del _conocimiento_
médico, que evoluciona con el tiempo.

[[doble-modelo]]
.Estrategia de doble modelo.
image::doble-modelo.png[scaledwidth="70%"]

Este modelo permite representar cualquier tipo concebible de estructura de datos de historia clínica, o parte de
ella, de forma consistente. Las principales ventajas de esta aproximación son:

* Interoperabilidad a nivel de conocimiento: la evolución del conocimiento puede ser compartida.
* Consulta y recuperación de la información eficaces: debido al conocimiento a priori de la estructura de la
información almacenada.
* Separación de tareas y responsabilidades: los modelos técnicos son desarrollados por ingenieros de software mientras
que el dominio clínico lo elaboran los médicos, los verdaderos conocedores del mismo.
* Los sistemas pueden evolucionar y cambiar con naturalidad, lo que facilita el mantenimiento a largo plazo.

En la parte de la izquierda de la <<doble-modelo>> se representa la _información_ clínica; hechos u opiniones
de o referidos a entidades específicas y que no varían con el paso del tiempo (_e.g._ el día 1 de enero el paciente X
tenía una presión arterial de 120/80 mmHg.). El _conocimiento_, representado en la parte derecha, comprende hechos
acumulados a lo largo del tiempo, procedente de muchas fuentes, que son verdad para todas las instancias de las
entidades del dominio y que pueden variar con el paso del tiempo (_e.g._ la medida de la presión arterial consta de dos
valores: la presión arterial sistólica y la presión arterial diastólica). Para cada uno de estos dos niveles se
tiene un modelo de datos. La _información_, los datos que se almacenan en el sistema, se componen a partir de los
elementos y la organización del <<_modelo_de_referencia, Modelo de Referencia>> (MR). Este modelo necesita reflejar la
estructura y la organización jerárquica de la HCE con el fin de ser fiel al contexto clínico original. El MR
representa el conjunto de clases que forman los componentes básicos de cualquier HCE, además de la información
jerarquizada de estas clases. Cada parte proporciona significado semántico claro a la hora de intercambiar HCE entre
distintos sistemas heterogéneos. El objeto de información por antonomasia en este tipo de estándares es el extracto
clínico. El _conocimiento_ representa los conceptos del dominio clínico, de manera que permita representar los datos
y se define mediante el <<_modelo_de_arquetipos, Modelo de Arquetipos>> (MA).

El Modelo de Arquetipos define el modelo que permite expresar arquetipos para cualquier MR, restringiéndolo (fijando
nombres, tipos de datos, valores por defecto, cardinalidades, etc.) para modelar formalmente conceptos del dominio
del conocimiento. Los arquetipos son acordados en una comunidad con el objetivo de garantizar la interoperabilidad
semántica, la consistencia de la información y la calidad de los datos. Este modelo consta de una serie da paquetes
que se verán en la <<_modelo_de_arquetipos>>. Los arquetipos son elementos jerárquicos formados por una serie
de nodos utilizando el patrón de diseño _Composite_, de manera que un nodo pueda contener de manera recursiva otros
nodos.

[[modelos-duales]]
__open__EHR: Modelo de Referencia y Modelo de arquetipos
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
En el modelo dual, el MR representa las características intrínsecas de cualquier de los componentes de registro de
la HCE, su organización y la información de contexto para satisfacer los requisitos ético-legales del registro. Para
conseguir la interoperabilidad, un modelo como este debe complementarse en el dominio del _conocimiento_ con una
metodología formal para definir conceptos del dominio clínico. Un arquetipo es combinación jerárquica de componentes
del MR con una serie de restricciones. Estas restricciones son las que permite definir el MA.

Modelo de Referencia
^^^^^^^^^^^^^^^^^^^^
El http://www.openehr.org/releases/RM/latest/docs/index[Modelo de Referencia] de __open__EHR es una representación de
los atributos genéricos de la información de la HCE, de su organización y de cómo se agregan, es decir define el
conjunto de clases que forman los componentes básicos de cualquier HCE, además de la organización de estas clases.

[[high_level_ehr_structure.png]]
.Estructura de alto nivel de registro de HCE.
image::high_level_ehr_structure[scaledwidth="60%"]

El registro de HCE de __open__EHR se estructura de acuerdo con un modelo relativamente sencillo. Un objeto EHR central
con un identificador único indica referencias a una serie de tipos de información estructurada y
versionada, además de una lista de objetos _Contribution_ que actúan como auditorías de conjuntos de cambios hechos a
la HCE.

En la figura anterior, las partes de la HCE que se muestran son las siguientes:

* _EHR_: el objeto raíz, con un identificador unívoco globalmente.
* _EHR_access (versioned)_: un objeto que contiene la configuración de control de acceso para el registro;
* _EHR_status (versioned)_: un objeto que contiene diferentes estados e información de control, incluyendo
opcionalmente el identificador del paciente asociado con el registro;
* _Directory (versioned)_: una estructura jerárquica opcional de _Carpetas_ que se puede utilizar para organizar de
forma lógica _Composiciones_;
* _Compositions (versión)_: los contenedores de todo el contenido clínico y administrativo del registro;
* _Contributions_: registro de cambios realizados en la HCE. Cada
_Contribution_ hace referencia a un conjunto de una o más _Versiones_ de cualquiera de los elementos versionados o
modificados en el registro de HCE.

La información clínica se estructura en _Compositions_. La _Composition_ es la unidad de información correspondiente al
resultado de un encuentro clínico o una sesión de registro de documentación en la HCE de un paciente. A continuación
se describe brevemente cómo es el paquete que contiene la información clínica que se inserta en dichas _Compositions_.

[[reference-model]]
.Paquete de información clínica de __open__EHR.
image::reference-model.png[scaledwidth="90%"]

El paquete `rm.data_structures` que se muestra a continuación contiene dos paquetes de importancia: el paquete
`item_structure` y el paquete `history`. El primero describe estructuras de datos genéricas, localizables mediante un
_path_, mientras que la segunda describe una noción genérica de historia lineal, para registrar eventos del pasado.
El paquete _representation_ contiene las clases para una representación jerárquica simple de cualquier estructura de
datos. Estas clases son compatibles con las clases UNE-EN ISO 13606 de los mismos nombres, y las instancias pueden
generarse sin pérdidas desde y hacia estructuras de instancias de la norma UNE-EN ISO 13606.

El paquete `data_structures` contiene una sola clase, `DATA_STRUCTURE`, que es la clase padre de todas las
estructuras de datos __open__EHR. Sólo tiene un método llamado `as_hierarchy`, que es implementado por cada subtipo de
`DATA_STRUCTURE` para generar una representación física de la estructura basada en la norma UNE-EN ISO 13606.

Las clases de paquete `item_structure` son una formalización de la necesidad de estructuras de datos genéricas y
arquetípicas, y son utilizadas por todos los modelos de referencia __open__EHR.

Los subtipos de la clase ITEM_STRUCTURE modelan explícitamente los tipos de datos de la estructura lógica que
normalmente se producen en los datos de registros de salud. Incluyen `ITEM_SINGLE` (para valores individuales como el
peso de un paciente), `ITEM_LIST` (para listas como partes de una dirección) ITEM_TREE (para datos estructurados de
forma jerárquica como un informe de microbiología) e `ITEM_TABLE` (para datos tabulares como la agudeza visual o los
resultados de las pruebas auditivas). Cada una de estas clases define una interfaz funcional, tiene una representación
física óptima utilizando los tipos básicos `CLUSTER` y `ELEMENT` del paquete de representación y puede generar una
representación jerárquica de sus datos compatible con UNE-EN ISO 13606. Cualquier sistema que implemente
estos tipos garantiza que generen datos que representen las estructuras lógicas de listas, tablas y árboles de
la misma manera.

Un objeto _Element_ tiene un único `DATA_VALUE` que contiene el valor, a menos que se indique como ausente mediante el
atributo `null_flavour`.

Modelo de arquetipos
^^^^^^^^^^^^^^^^^^^^
El Modelo de arquetipos<<AOM15>> define un modelo de objetos que permite expresar arquetipos (capa del
_conocimiento_). El modelo de arquetipos es independiente del MR, es decir, no sólo se utiliza para el MR de
__open__EHR, sino que hay otros estándares, como UNE-EN ISO 13606, que también lo utilizan.

Un arquetipo es la definición de una combinación jerarquizada de componentes del MR, al cual restringe (estableciendo
nombres, rangos permitidos, tipos de datos posibles, valores por defecto, cardinalidad, etc.), para modelar
conceptos clínicos del dominio del _conocimiento_. Estas estructuras, aunque suficientemente estables, pueden
modificarse o sustituirse por otras a medida que la práctica clínica evolucione. Los arquetipos son instancias del
modelo de arquetipos, que restringen el MR para que las instancias de este sean representaciones de los conceptos
modelados del dominio.

[[aom]]
.Estructura de paquetes del modelo de arquetipos.
image::aom.png[scaledwidth="70%"]

A continuación se muestra la estructura del paquete _archetype_ (<<archetype-package-aom>>) y del paquete de
restricciones _constraint_model_ (<<constraint-model>>)

[[archetype-package-aom]]
.Paquete _archetype_ del MA.
image::archetype-package-aom.png[scaledwidth="60%"]

[[constraint-model]]
.Paquete _constraint_ del MA.
image::constraint-model.png[scaledwidth="60%"]

La formación de nodos de arquetipos se realiza imponiendo restricciones al MR utilizando el paquete _constraint_ del
MA. Un nodo de un arquetipo se representa por un objeto de la clase _C_Complex_Object_, que puede tener por
composición varios objetos clase _C_Attribute_, que tiene subclases _C_Single_Attribute_ y _C_Multiple_Attribute_. A su
vez, un objeto _C_Attribute_ puede tener por composición varios objetos clase _C_Object_, que es superclase de
_C_Complex_Object_ y de _C_Primitive_Object_. Esta estructura hace que un nodo pueda tener como atributos los nombres de
otros nodos, cuyas clases (_C_Complex_Object_) tienen atributos con el tipo de nodo que es (es decir, Composition,
Entry, Element, etc.), y a su vez otros atributos apuntando a sus nodos descendientes, formando un árbol cuyas hojas
son objetos de la clase _C_Primitive_Object_.

Cada clase del MA tiene, además de sus atributos, atributos derivados de asociaciones y métodos, una serie de
restricciones expresadas como invariantes sobre sus atributos. Estas invariantes son cláusulas lógicas que deben
cumplir siempre y en todo momento los atributos de cualquier implementación de la clase que siga la especificación de
la norma.

Los arquetipos, al igual que las guías clínicas con el GDL, se definen mediante un lenguaje formal, denominado
Archetype Definition Language<<BEAL07>> (ADL), que proporciona una sintaxis abstracta para la definición de estos
arquetipos. Esta sintaxis es semánticamente equivalente al MA, por lo que se puede traducir entre ambos utilizando
un _parser_ de ADL. El lenguaje ADL usa una combinación de dos sintaxis: _dADL_ (ADL de definición) y
_cADL_ (ADL de restricciones).

[[adl]]
.Definición de arquetipos con lenguaje ADL.
image::adl.png[scaledwidth="50%"]

_dADL_, el lenguaje de definición de datos, proporciona una sintaxis para definir instancias de objetos basadas en un
MR subyacente y que puede ser leído por humanos y por máquinas. A continuación se muestra un fragmento de un
arquetipo escrito en dADL.

image::dadl-example.png[scaledwidth="50%"]
----
description
  original_author = <
    ["organisation"] = <“Universidade de A Coruña">
    ["name"] = <“Jesús Barros">
    ["date"] = <"20170612">
  >
  lifecycle_state = <"Draft">
  details = <
    ["es"] = <
      language = <[ISO_639-1::es]>
      copyright = <“">
    >
  >
----

_cADL_, la sintaxis para expresar restricciones permite restringir datos definidos por modelos de información
orientados a objetos u otros formalismos de definición de conocimiento. Se utiliza para la sección _definition_ de
los arquetipos, donde se definen los conceptos clínicos utilizando restricciones sobre el MR. A continuación se
muestra un fragmento de la sección _definition_ de un arquetipo de _Presión arterial_, definido por expertos en el
dominio.

----
definition
  OBSERVATION[at0000] matches {	-- Blood Pressure
    data matches {
      HISTORY[at0001] matches {	-- history
	    events cardinality matches {1..*; unordered} matches {
		  EVENT[at0006] occurrences matches {0..*} matches {	-- Any event
		    data matches {
			  ITEM_TREE[at0003] matches {	-- blood pressure
			    items cardinality matches {0..*; unordered} matches {
				  ELEMENT[at0004] occurrences matches {0..1} matches {	-- Systolic
				    value matches {
					  C_DV_QUANTITY <
					    property = <[openehr::125]>
						list = <
						  ["1"] = <
						    units = <"mm[Hg]">
							magnitude = <|0.0..<1000.0|>
							precision = <|0|>
						  >
						>
					  >
					}
				  }
				  ELEMENT[at0005] occurrences matches {0..1} matches {	-- Diastolic
				    value matches {
					  C_DV_QUANTITY <
					    property = <[openehr::125]>
						list = <
						  ["1"] = <
						    units = <"mm[Hg]">
							magnitude = <|0.0..<1000.0|>
							precision = <|0|>
						  >
						>
				      >
					}
				  }
	.........
  }
----

En el ejemplo anterior se restringe el MR de __open__EHR para definir dos nodos dentro del concepto _Presión
arterial_. Como se puede apreciar es una estructura jerárquica donde cada nodo es accesible por medio de un _path_,
así se puede referenciar al valor de la presión arterial sistólica mediante el path:
`data/[at0001]/events/[at006]/data/[at0003]/items[at0004]/value/magnitude`. Estos son los _paths_ unívocos que se
utilizan desde GDL para referenciar elementos o atributos de arquetipos. Resumiendo un poco, en el anterior
fragmento, se puede observar cómo se define la presión arterial, con un _elemento_ `ITEM_TREE` del MR, cuyo atributo
_items_ se restrinja para que tenga una lista de elementos, en este caso con una cardinalidad de cero a infinito. Se
define un `ELEMENT` que representa la presión arterial sistólica, a este nodo se le aplica una restricción de
ocurrencia, indicando que puede existir cero o una instancia de este nodo. A continuación se indica que su atributo
value es de tipo `C_DV_QUANTITY` definido en el MR. Se restringe el tipo de dato obligándole a que las unidades se
midan en mm. de Hg., se le aplica un rango obligándole a que el valor esté entre 0 y 1.000 y se indica la precisión,
el número de decimales que debe tener el valor, que en este caso es de cero.

Terminologías clínicas
~~~~~~~~~~~~~~~~~~~~~~
La normalización y la comunicación de términos con una precisión aceptable ya se ha conseguido hace muchos años con
la introducción de sistemas de clasificación y codificación. Existen otros recursos como los diccionarios o los
tesauros que han facilitado la normalización de significados de palabras y expresiones a través de enlaces de
significado. Este tipo de recursos permite la interpretación no ambigua de las palabras, pero no trabaja con
conceptos, sino que lo hacen con palabras aisladas.

Las terminologías clínicas tratan de preservar la precisión en la expresión de conceptos, pero intentan representarlos
de tal forma que su formulación, su recuperación, su tratamiento automatizado, su comunicación, su comprensión y
utilización se hagan sin ambigüedad.

A continuación se describen tres de las terminologías más utilizadas actualmente en la sanidad:

SNOMED CT
^^^^^^^^^
Sistematic NOmenclature of MEDicine – Clinical Terms (SNOMED CT) está considerada como la terminología clínica
integral, multilingüe y codificada de mayor amplitud, precisión e importancia desarrollada en el mundo
actualmente<<MSAN17>>, mantenida y distribuida por el IHTSDO<<IHTS17>>.

SNOMED CT proporciona un intercambio de información consistente y es fundamental para un registro electrónica de salud
interoperable. Proporciona un medio consistente para indexar, almacenar, recuperar y agregar datos clínicos a través
de especialidades y lugares de atención sanitarias. También ayuda a organizar el contenido de los sistemas
de HCE reduciendo la variabilidad en la forma en que se capturan, codifican y utilizan los  datos para la
atención clínica de los pacientes y la investigación<<RUCH12>>.

Se trata de una terminología orientada a conceptos y esto es la clave de la potencia y la flexibilidad de SNOMED CT.
La variabilidad en el lenguaje puede responder a factores culturales o patrones de uso local difíciles de cambiar,
pero las distintas descripciones de un concepto quedan asociadas a un identificador unificado de dicho concepto.

Como las descripciones equivalentes señalan a un mismo concepto, es relativamente sencillo establecer las relaciones
entre conceptos sin necesidad de crearlas para cada posible descripción. Al asociar conceptos mediante relaciones de
acuerdo a un esquema conceptual prediseñado, podemos dotar a la terminología de algunas (no todas) las
características clave de las ontologías: permiten representar conocimiento de manera formal y no ambigua, de forma
interpretable por un componente de software.

En SNOMED CT se encuentran conceptos que pertenecen a una amplia variedad de ejes semánticos. En el nivel superior se
encuentra el concepto raíz de la terminología, un concepto único que actúa como origen de todos los significados,
denominado _Concept_. Por debajo del concepto raíz, se encuentran 19 jerarquías principales. Bajo cada uno de los
conceptos de jerarquía principal se agrupan los restantes conceptos.

[[snomed-ct-hierarchy]]
.Jerarquía de conceptos en SNOMED CT.
image::snomed-ct-hierarchy.png[scaledwidth="50%"]

SNOMED CT puede utilizarse directamente para registrar los datos clínicos de los pacientes en la HCE. También
proporciona al usuario una serie de relaciones a las guías de atención clínica, planes de cuidado compartidos y otros
recursos de conocimiento, con el fin de facilitar la toma de decisiones y apoyar la atención sanitaria del paciente
a largo plazo. La disponibilidad de herramientas y servicios de codificación automática gratuitosfootnote:[Navegador
SNOMED CT: http://browser.ihtsdotools.org/], que pueden devolver una lista clasificada de descriptores SNOMED CT para
codificar cualquier informe clínico, podría ayudar a los profesionales de la salud a navegar por la terminología.

SNOMED CT consta de cuatro componentes principales:

* Códigos de concepto: códigos numéricos que identifican términos clínicos, primitivos o definidos, organizados
jerárquicamente.
* Descripciones: descripciones textuales de los códigos de concepto mencionados anteriormente.
* Relaciones: relaciones entre códigos de conceptos que estén vinculados de alguna manera.
* Conjuntos de referencia: se utilizan para agrupar conceptos o descripciones en conjuntos, incluidos conjuntos de
referencias y referencias cruzados con otras clasificaciones y normas, como CIE-10.

Los conceptos de SNOMED CT son unidades representativas que categorizan todas las cosas que caracterizan los procesos de
atención sanitaria y necesitan ser registradas en la HCE. En 2011, SNOMED CT incluía más de 311.000 conceptos, que
los cuales estaban unívocamente identificados por un ID de concepto, _e.g._ el concepto 22298006 se refiere a _Infarto
de miocardio_. Todos los conceptos SNOMED CT se organizan en jerarquías taxonómicas (_IS_A_) acíclicas; por ejemplo,
_Neumonía viral_ IS_A _Neumonía infecciosa_ IS-A _Neumonía_ IS-A _Enfermedad pulmonar_. Los conceptos pueden tener
múltiples padres, por ejemplo, la _Neumonía infecciosa_ es también un concepto hijo de _Enfermedad infecciosa_. La
estructura taxonómica permite registrar los datos y para que posteriormente sean accesibles en diferentes niveles de
agregación.

CIE-10
^^^^^^
La CIE-10 es el acrónimo de la Clasificación internacional de enfermedades, décima versión correspondiente a la
versión en español de la (en inglés) ICD, siglas de International Statistical Classification of Diseases and Related
Health Problems y determina una clasificación y codificación de las enfermedades y una amplia variedad de signos,
síntomas, hallazgos anormales, denuncias, circunstancias sociales y causas externas de daños y/o enfermedades.
publicada y gestionada por la Organización Mundial de la Salud (OMS).

El conjunto de códigos contiene más de 14.400 códigos diferentes y permite el seguimiento de muchos nuevos
diagnósticos. Los códigos pueden ampliarse a más de 16.000 códigos mediante subclasificaciones opcionales<<CIEM17>>.

La CIE fue publicada por la Organización Mundial de la Salud. Se utiliza a nivel internacional para fines
estadísticos relacionados con morbilidad y mortalidad, los sistemas de reintegro y soportes de decisión automática en
medicina. Este sistema está diseñado para promover la comparación internacional de la recolección, procesamiento,
clasificación y presentación de estas estadísticas.

La OMS proporciona información _on-line_ detallada sobre la CIE y pone a disposición un conjunto de materiales
_on-line_, como un navegador en línea de la CIE-10footnote:[http://apps.who.int/classifications/icd10/browse/2016/en#/: última versión disponible en el momento de escribir este documento],
cursos de formación de la CIE-10footnote:[http://apps.who.int/classifications/apps/icd/icd10training/], ayuda a la
formación _on-line de CIE-10footnote:[http://sites.google.com/site/icd10onlinetraining] y materiales de estudio para
su descarga.

Cada condición de salud puede ser asignada a una categoría y recibir un código de hasta seis caracteres de longitud
(en formato de X00.00). Cada una de tales categorías puede incluir un grupo de enfermedades similares. Los siguientes
códigos se utilizan por la Clasificación Estadística Internacional de Enfermedades y Problemas Relacionados con la
Salud.

En el <<cie10-table>> se pueden observar las categorías en las que se agrupan los códigos CIE-10.

[[cie10-table]]
.Capítulos de CIE-10.
[cols="^10%,10%,80%", options="header"]
|===
|Capítulo   |Códigos    |Títulos
|I          |A00-B99    |Ciertas enfermedades infecciosas y parasitarias
|II         |C00-D48    |Neoplasias
|III        |D50-D89    |Enfermedades de la sangre y de los órganos hematopoyéticos y otros trastornos que afectan el mecanismo de la inmunidad
|IV         |E00-E90    |Enfermedades endocrinas, nutricionales y metabólicas
|V          |F00-F99    |Trastornos mentales y del comportamiento
|VI         |G00-G99    |Enfermedades del sistema nervioso
|VII        |H00-H59    |Enfermedades del ojo y sus anexos
|VIII       |H60-H95    |Enfermedades del oído y de la apófisis mastoides
|IX         |I00-I99    |Enfermedades del sistema circulatorio
|X          |J00-J99    |Enfermedades del sistema respiratorio
|XI         |K00-K93    |Enfermedades del aparato digestivo
|XII        |L00-L99    |Enfermedades de la piel y el tejido subcutáneo
|XIII       |M00-M99    |Enfermedades del sistema osteomuscular y del tejido conectivo
|XIV        |N00-N99    |Enfermedades del aparato genitourinario
|XV         |O00-O99    |Embarazo, parto y puerperio
|XVI        |P00-P96    |Ciertas afecciones originadas en el periodo perinatal
|XVII       |Q00-Q99    |Malformaciones congénitas, deformidades y anomalías cromosómicas
|XVIII      |R00-R99    |Síntomas, signos y hallazgos anormales clínicos y de laboratorio, no clasificados en otra parte
|XIX        |S00-T98    |Traumatismos, envenenamientos y algunas otras consecuencias de causa externa
|XX         |V01-Y98    |Causas externas de morbilidad y de mortalidad
|XXI        |Z00-Z99    |Factores que influyen en el estado de salud y contacto con los servicios de salud
|XXII       |U00-U99    |Códigos para situaciones especiales
|===

CIAP 2
^^^^^^
Son las siglas de Clasificación Internacional de la Atención Primaria, versión 2, esta terminología permite la
recogida y análisis de tres importantes componentes de la consulta médico-paciente: la razón de la consulta, el
problema atendido y el proceso de atención. La estructura de esta clasificación está diseñada para ordenar, investigar y
entender mejor el contenido de la Medicina de Familia y de la Atención Primaria.

Desarrollada la primera edición por la WONCA (Organización Mundial de los Médicos Generales/de Familia) en 1987 y
la segunda edición en 1998. Se tradujeron al español en 1988 y 1999 respectivamente. Actualmente está traducida a más
de 20 idiomas.

Tiene una estructura biaxial: capítulos y componentes, por un lado consta de 17 capítulos organizados en aparatos
físicos y sistemas orgánicos, cada entrada tiene su código alfanumérico de tres caracteres, ampliables si se
considera necesario. El primer carácter representa cada uno de los aparatos y el segundo y tercer carácter son
dígitos que forman los componentes del otro eje, que se relacionan con: signos o síntomas; procedimientos
administrativos diagnósticos, preventivos o terapéuticos; resultados de pruebas complementarias; derivaciones,
seguimiento y otras razones de consulta; o enfermedades y problemas de salud.

La CIAP-2 (ver <<ciap2-table>>) contiene 17 capítulos, diferenciados por una letra, que corresponden a un código nemotécnico en
inglés:

[[ciap2-table]]
.Capítulos de CIAP-2.
[cols="^10%,90%", options="header"]
|===
|Capítulo   |Descripción
|A          |Problemas generales e inespecíficos
|B          |Sangre, órganos hematopoyéticos y sistema inmunitario (linfáticos, bazo y médula ósea)
|D          |Aparato digestivo
|F          |Ojo y anejos
|H          |Aparato auditivo (H de Hearing)
|K          |Aparato circulatorio
|L          |Aparato locomotor
|N          |Sistema nervioso
|P          |Problemas psicológicos
|R          |Aparato respiratorio
|S          |Piel y faneras (S de Skin)
|T          |Aparato endocrino, metabolismo y nutrición
|U          |Aparato urinario
|W          |Planificación familiar, embarazo, parto y puerperio (W de _Women_, referido a la reproducción)
|X          |Aparato genital femenino y mamas (X, de cromosoma X)
|Y          |Aparato genital masculino y mamas (Y, de cromosoma Y)
|Z          |Problemas sociales
|===

Especificación GDL
~~~~~~~~~~~~~~~~~~
Introducción y requisitos
^^^^^^^^^^^^^^^^^^^^^^^^^
.Propósito.
Expresar y compartir contenido computarizado de apoyo a la toma de decisiones clínicas (CDS) a través de lenguajes y
plataformas técnicas ha sido un objetivo evasivo durante mucho tiempo. La falta de modelos de información clínica
compartidos compartidos y el apoyo flexible para los diferentes recursos de terminologías se han identificado como dos
retos principales para compartir la lógica de decisión entre sistemas. GDL es un lenguaje formal para expresar
lógica de soporte a las decisiones. Está diseñado para ser agnóstico a los lenguajes naturales y terminologías clínicas
aprovechando los diseños del MR y MA de __open__EHR.

El alcance del GDL es expresar la lógica clínica como reglas de producción. Las reglas GDL discretas, que cada una de
las cuales contienen declaraciones `if-then`, pueden combinarse como piezas para dar soporte a procesos de toma de
decisiones sencillo y a procesos de toma de decisiones más complejos. Las reglas GDL pueden usarse para llevar a cabo
la toma de decisiones en aplicaciones en consulta, así como en analíticas poblacionales retrospectivas.

.Documentos relacionados.
* Modelo de Referencia de __open__EHR
** Modelo de Información de Tipos de Datos (http://www.openehr.org/releases/1.0.2/architecture/rm/data_types_im.pdf[1.0.2])
** Modelo de Información de Estructuras de Datos (http://www.openehr.org/releases/1.0.2/architecture/rm/data_structures_im.pdf[1.0.2])
** Modelo de Información de HCE (http://www.openehr.org/releases/1.0.2/architecture/rm/ehr_im.pdf[1.0.2])
** Modelo de Información Común (http://www.openehr.org/releases/1.0.2/architecture/rm/common_im.pdf[1.0.2])
* Modelo de Arquetipos de __open__EHR
** Modelo de Objetos de Arquetipos (AOM) (http://www.openehr.org/releases/1.0.2/architecture/am/aom.pdf[1.0.2])
** Lenguaje de Definición de Arquetipos (ADL) (http://www.openehr.org/releases/1.0.2/architecture/am/adl.pdf[1.0.2])

.Requisitos
. Debe ser posible expresar las reglas de CDS usando arquetipos como entrada y como salida de la ejecución de reglas.
. Debe ser independiente del lenguaje natural y debe ser capaz de soportar traducciones a diferentes idiomas sin
cambiar la definición de las reglas.
. Debe ser independiente de las terminologías de referencia, por lo que pueden utilizarse terminologías diferentes para
apoyar el razonamiento.
. Debe ser sencillo convertir las reglas CDS en reglas expresadas en los principales lenguajes de uso común para su ejecución.
. Debe haber suficiente meta-información acerca sobre las reglas CDS, _e.g._. autoría, propósito, versiones y referencias relevantes.
. Debe ser posible reutilizar las reglas CDS en diferentes contextos clínicos.
. Debería ser posible agrupar un conjunto de normas CDS relacionadas con el fin de apoyar la toma de decisiones
complejas.

Principios de diseño
^^^^^^^^^^^^^^^^^^^^^
Teniendo en cuenta los requisitos mencionados anteriormente, se han tomado las siguientes decisiones de diseño.

.Arquetipos tanto como entradas como salidas de las reglas.
Esto se consigue mediante la creación de enlaces entre los elementos de los datos definidos por los arquetipos y las
variables utilizadas por las reglas del CDS. Cada variable de regla CDS se identifica de forma unívoca en el contexto
de una guía y se enlaza con un elemento específico definido por un arquetipo utilizando su _Archetype ID_ y
su __path__footnote:[El _path_ de un elemento de un arquetipo es la ruta unívoca que identifica dicho elemento dentro
del arquetipo.]. Una vez definida, la variable se puede usar dentro de las sentencias _when_ y _then_ como entrada o
como salida durante la ejecución de la regla.

.Independencia del lenguaje natural.
Se han utilizado varias ideas de diseño del formalismo de arquetipos de __open__EHR para lograr la neutralidad del
lenguaje natural. En primer lugar, toda la meta-información dependiente del idioma sobre el propósito, el uso, el uso
desaconsejado y las referencias de las reglas se agrupan bajo la sección _description_ y se indexan por los códigos
de idioma ISO dentro de la guía. En segundo lugar, todas las etiquetas y descripciones dependientes del lenguaje
natural, _e.g._ el nombre de una variable de regla, se definen en la sección _term_definitions_ de la guía y
se indexan mediante códigos de idioma ISO. En tercer lugar, en las expresiones de la regla, se utilizan los
identificadores únicos de variables y reglas, en lugar de sus nombres, ya que estos últimos dependen del idioma.

.Independencia de terminologías de referencia.
Cuando se utiliza el operador _IS_A_ en las instrucciones de evaluación para la verificación de relaciones de
pertenencia, se utiliza un término definido localmente en lugar de un código externo. Esta indirección hace posible
modificar el código o añadir nuevos códigos de otras terminologías sin cambiar las definiciones de las reglas. Los
enlaces entre los códigos definidos localmente y las terminologías de referencia externas se mantienen en la sección
_term_bindings_ del documento GDL.

.Independencia del lenguaje de reglas.
GDL sólo utiliza un conjunto de características comunes de lenguaje de reglas, como _when_ y _then_. Las expresiones
en las declaraciones _when_ y _then_ soportan cálculos aritméticos comunes, operadores lógicos y funciones.

.Agrupación y reutilización de reglas.
Un documento GDL (guía clínica) puede contener varias reglas que se relacionen entre sí. Cada guía es autocontenida y
debe ser reutilizable en diferentes contextos clínicos. Se pueden encadenar diferentes guías para permitir el soporte de
decisiones complejas. Esto se logra seleccionando la salida de una regla, como un elemento específico de un
arquetipo, como entrada de otra regla.

.Meta-información de las reglas CDS.
La información de autoría, el estado del ciclo de vida y varias meta-informaciones son compatibles con la reutilización
de la clase _RESOURCE_DESCRIPTION_ del diseño __open__EHR.

Modelo de Objetos de Guías Clínicas
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Los fundamentos del diseño de GDL son los arquetipos __open__EHR, tanto como entrada como salida de las reglas CDS.
Esta es la clave para conseguir la independencia lingüística y de las terminologías de referencia. Debido a esta
elección de diseño, la especificación __open__EHR juega un papel importante en el diseño GDL. En otras palabras, el
diseño GDL tiene como objetivo hacer una reutilización sustancial de las especificaciones __open__EHR existentes. En
áreas donde el diseño __open__EHR existente no es suficiente, se introducen diseños adicionales.

El modelo de objetos de guía (Guide Object Model, GOM), el modelo de objetos del GDL, consta de dos paquetes: el
_paquete guía_ y el _paquete de expresiones_ descrito en detalle a través de las dos secciones siguientes.

Paquete de Guías Clínicas
^^^^^^^^^^^^^^^^^^^^^^^^^
La vista general del _paquete guía_ se ilustra en la <<gom>>. Las clases en color azul se basan, en líneas generales,
en el diseño original de las especificaciones __open__EHR.

[[gom]]
.Paquete ``guía clínica''.
image::gdl-relational-model.png[]

.GUIDE.
Clase principal de una guía discreta que define enlaces a arquetipos, reglas y meta-información.

.Clase _Guide_
[cols="10%,40%,50%", options="header"]
|===
|Atributos  |Firma                              |Significado
|0..1       |gdl_version: String                |La versión en la que está escrita la guía.
|1..1       |id: String                         |Identificador de la guía clínica.
|1..1       |concept: String                    |El significado normativo de la guía en su conjunto. Expresado como un código de guía local.
|1..1       |language: Language                 |Recursos en lenguaje natural de esta guía. Incluye un idioma original y una lista opcional de traducciones.
|1..1       |description: RESOURCE_DESCRIPTION  |Descripción de los recursos de esta guía incluyendo autoría, uso / mal uso, ciclo de vida y referencias.
|1..1       |definition: GUIDE_DEFINITION       |La parte de definición principal de la guía. Consiste en enlaces de arquetipos y definiciones de reglas.
|1..1       |ontology: GUIDE_ONTOLOGY           |La ontología de la guía.
|===

.GUIDE_DEFINITION.
La definición de la guía incluye una lista de enlaces de arquetipos y una lista de definiciones de reglas.

[[table-guide-definition]]
.Clase _GuideDefinition_
[cols="10%,40%,50%", options="header"]
|===
|Atributos  |Firma                                          |Significado
|1..1       |archetype_bindings: List<ARCHETYPE_BINDING>    |Lista de enlaces de arquetipos, que definen elementos específicos a ser utilizados por las reglas.
|1..1       |rules: Map<String, Rule>                       |Mapa de reglas, indexado por un código _gt_ local.
|0..1       |pre_conditions: List<EXPRESSION_ITEM>          |Lista de pre-condiciones que tienen que ser cumplidas para que una guía pueda ser ejecutada.
|===

.ARCHETYPE_BINDING.
El enlace de la lista de elementos de un arquetipo o plantilla seleccionado a los códigos _gt_ locales

.Clase _ArchetypeBinding_
[cols="10%,40%,50%", options="header"]
|===
|Atributos      |Firma                                          |Significado
|1..1           |archetype_id: String                           |El ID del arquetipo desde el que se selecciona la lista de elementos.
|0..1           |template_id: String                            |ID de una plantilla opcional que se utilizará para seleccionar elementos.
|0..1           |domain: String                                 |El espacio en el que residen las variables de regla. El valor puede ser "EHR" (cuando el valor se recupera del EHR) o "CDS" (cuando el valor deriva del motor CDS). Cuando no existe. Valor por defecto: "EHR".
|1..1           |Elements: Map<String, ELEMENT_BINDING>         |Mapa de _element bindings_ indexados por código _gt_.
|0..1           |predicate_statements: List<EXPRESSION_ITEM>    |Lista de predicados (restricciones) que deben cumplirse antes de que se puedan realizar las consultas de a la HCE
|===

.ELEMENT_BINDING.
La vinculación entre un elemento específico de un arquetipo y una variable local en la guía.

.Clase _ElementBinding_.
[cols="10%,40%,50%", options="header"]
|===
|Atributos  |Firma          |Significado
|1..1       |id: String     |El _código gt_ local del elemento
|1..1       |path: String   |El _path_ para llegar a este elemento dentro del arquetipo.
|===

.RULE.
Una regla definida en una guía.

.Clase _Rule_.
[cols="10%,40%,50%", options="header"]
|===
|Atributos      |Firma                                          |Significado
|1..1           |id: String                                     |El _código gt_ local de la guía
|1..1           |when_statements: List<EXPRESSION_ITEM>         |Lista de expresiones a evaluar antes de que se pueda ejecutar la regla.
|1..1           |then_statements: List<ASSIGNMENT_EXPRESSION    |Lista de expresiones para generar salida de la regla..
|===

Paquete de Expresiones
^^^^^^^^^^^^^^^^^^^^^^
El paquete de expresiones se muestra en la <<paquete-expresiones>>.

[[paquete-expresiones]]
.Paquete de Expresiones.
image::expression-relational-model.png[]

.EXPRESSION_ITEM.
Modelo abstracto de un ítem de expresión en una regla.

.UNARY_EXPRESSION.
Modelo abstracto de un ítem de expresión en una regla. Hereda de EXPRESSION_ITEM

.Clase _Unary Expression_.
[cols="10%,40%,50%", options="header"]
|===
|Atributos      |Firma                      |Significado
|1..1           |operand: EXPRESSION_ITEM   |El operando de la expresión unaria.
|1..1           |operator: OPERATOR_KIND    |El operador de la expresión unaria.
|===

.BINARY_EXPRESSION.
Modelo concreto de una expresión binaria. Hereda de EXPRESSION_ITEM.

.Clase _BinaryExpression_.
[cols="10%,40%,50%", options="header"]
|===
|Atributos      |Firma                      |Significado
|1..1           |left: EXPRESSION_ITEM      |El operando izquierdo de la expresión binaria.
|1..1           |right: EXPRESSION_ITEM     |El operando derecho de la expresión binaria.
|1..1           |operator: OPERATOR_KIND    |El operador de la expresión binaria.
|===

.ASSIGNMENT_EXPRESSION.
Modelo concreto de una expresión de asignación. Hereda de EXPRESSION_ITEM.

.Clase _AssignmentExpression_.
[cols="10%,40%,50%", options="header"]
|===
|Atributos      |Firma                      |Significado
|1..1       |variable: String               |El _código gt_ de la variable a la cual asignar el valor.
|1..1       |assignment: EXPRESSION_ITEM    |El _expression item_ del que deriva el valor.
|===

.FUNCTIONAL_EXPRESSION.
Expresión concreta que modela una función. Hereda de EXPRESSION_ITEM.

.Clase _FunctinalExpression_.
[cols="10%,40%,50%", options="header"]
|===
|Atributos      |Firma                          |Significado
|1..1           |function: Kind                 |El tipo de función utilizada.
|1..1           |items: List<EXPRESSION_ITEM>   |Lista de parámetros para la función.
|===

.OPERATOR_KIND.
Enumerado que contiene todos los operadores utilizados.

[[operator-kind]]
.Clase _OperatorKind_.
[options="header"]
|===
|Tipo                           |Nombre                 |Símbolo
|Aritmético                     |Suma                   |+
|Aritmético                     |Resta                  |-
|Aritmético                     |Multiplicación         |*
|Aritmético                     |División               |/
|Aritmético                     |Exponente              |^
|Lógico                         |And                    |&&
|Lógico                         |Or                     |\|\|
|Lógico                         |Not                    |!
|Relacional                     |Igual                  |==
|Relacional                     |Distinto               |!=
|Relacional                     |Menor que              |<
|Relacional                     |Menor o igual que      |<=
|Relacional                     |Mayor que              |>
|Relacional                     |Mayor o igual que      |>=
|De asignación                  |De asignación          |=
|De pertenencia terminológica   |Es un                  |is_a
|De pertenencia terminológica   |No es una              |!is_a
|===

.FUNCTION_KIND.
Tipos de funciones permitidas

.Funciones permitidas.
[cols="20%,80%", options="header"]
|===
|Nombre |Función
|abs    |Devuelve el valor absoluto de un valor _double_.
|ceil   |Devuelve el valor _double_ más pequeño que sea mayor o igual que el argumento e igual a un entero matemático.
|exp    |Devuelve el número de Euler _e_ elevado a la potencia de un valor _double_.
|floor  |Devuelve el mayor valor _double_ que es menor o igual que el argumento y es igual a un entero matemático.
|log    |Devuelve el logaritmo natural (en base _e_) de un valor _double_.
|log10  |Devuelve el logaritmo en base 10 de un valor _double_.
|log1p  |Devuelve el logaritmo natural de la suma del argumento más 1.
|round  |Devuelve el _long_ más cercano al argumento.
|sqrt   |Devuelve la raíz cuadrada positiva correctamente redondeada de un valor _double_.
|max    |Se utiliza para obtener el valor máximo de un elemento.
|min    |Se utiliza para obtener el valor mínimo de un elemento.
|===

Ejemplo de guía GDL
^^^^^^^^^^^^^^^^^^^
A continuación se muestra un ejemplo sencillo del código fuente de una guía en formato GDL que nos permite calcular el
https://es.wikipedia.org/wiki/Escala_CHA2DS2-VASc[CHA2DS2VASc Score], un instrumento clínico para la
determinación del riesgo de accidente cerebrovascular en pacientes con fibrilación auricular. Las definiciones para
las palabras reservadas de GDL usadas aquí se han visto en los capítulos anteriores. Los metadatos en el
encabezado GDL se basan en la sección _description_ de ADL de __open__EHRfootnote:[Ver sección 8.3.6 (_description_) de
la especificación ADL: http://www.openehr.org/releases/1.0.1/architecture/am/adl.pdf], es análoga a la definición de
la descripción de arquetipos.

En lo sucesivo de este documento, en ocasiones, se utilizará el término ``guía'' un nombre abreviado para referirse a
un documento GDL.

----
include::samples/CHA2DS2VASc-header.v1.gdl[]
----

<1> Versión actual de la guía.
<2> Identificador unívoco.
<3> Representación del concepto principal de la guía. Siempre con un código local para posibilitar traducciones.
<4> Lenguaje original y lenguajes soportados.
<5> Descripción de la guía.
<6> Estado del ciclo de vida.
<7> Autor original.
<8> Otros colaboradores.

La correspondencia con la vista del editor puede verse en la <<_description>>.

El siguiente bloque muestra la sección `archetype_binding` dentro de la sección `guide_definition`, la cual vincula
elementos de los arquetipos clínicos con variables usadas en las reglas GDL. Por cuestiones de espacio sólo se
mostrará uno de ellos.

----
include::samples/gdl-definition-1.gdl[]
----

<1> Sección _definition_: contenedor de enlaces con arquetipos, precondiciones y reglas.
<2> Identificador unívoco del arquetipo que contiene los elementos que se enlazan con términos locales.
<3> Dominio: puede ser _EHR_, _CDS_ o _ANY_. Ver <<table-guide-definition>>.
<4> Contenedor de elementos vinculados.
<5> Vinculación: al término local cuyo código es _gt0107_ se le hace corresponder con el elemento del arquetipo
_openEHR-EHR-EVALUATION.problem-diagnosis.v1_ cuyo _path_ dentro del arquetipo es `/data[at0001]/items[at0002.1]`.

Dentro de la `guide_definition`, se puede definir un conjunto de condiciones que deben cumplirse para que
puedan ejecutar las reglas de de la guía. En el caso del cálculo de la puntuación CHA2DS2-VASc, la guía no se
ejecutará a menos que el paciente haya sido diagnosticado con _fibrilación auricular_. En el ejemplo siguiente, una
precondición verifica la existencia de _fibrilación auricular_ en el diagnóstico del paciente (gt0107).
Utilizando el predicado de la sección _definition_, se establece la precondición para comprobar contra un
código local (gt0105) que representa el significado de _fibrilación auricular_. Este código puede estar ligado a un
concepto definido formalmente por terminologías externas, _e.g._ SNOMED CT, en la sección _term_bindings_.

----
include::samples/gdl-definition-2.gdl[]
----

<1> Predicado donde se define la condición de de que el diagnóstico (`gt0107`) sea de _fibrilación auricular (gt0105)_.
<2> Precondición que verifica la presencia o ausencia de _fibrilación auricular_ en el diagnóstico del paciente.

La sección _rules_ hace uso exclusivo de las variables definidas localmente para expresar la lógica clínica. Cada
regla tiene un nombre codificado por un _código gt_ definido localmente, cuyo nombre y descripción, que dependen del
lenguaje natural, se indexan en la sección _term_definitions_. También se puede asignar una prioridad para asegurar
el orden de ejecución de las reglas. Este ejemplo ilustra las reglas que inspeccionan diferentes diagnósticos
relevantes para la puntuación CHA2DS2-VASc y establecen los valores correspondientes a los DV_ORDINALsfootnote:[Tipo
de dato de __open__EHR, definido en el MR:
http://www.openehr.org/releases/RM/latest/docs/data_types/data_types.html#_dv_ordinal_class] existentes en
el arquetipo correspondiente, en este caso el arquetipo CHA2DS2-VASc. La regla `gt0026`, (``Calcular puntuación total'')
suma todos los valores y asigna la puntuación total.

----
include::samples/gdl-rules.gdl[]
----

En la sección _ontology_ de la guía, todos los términos se enlazan a con un texto, normalmente para etiquetas de
interfaces de usuario y una descripción--para cualquier otro uso--de los términos en los lenguajes naturales soportados.

----
include::samples/gdl-terminology.gdl[]
----

Además, los términos locales, en la sección _term_bindings_, se pueden enlazar con conceptos definidos por terminologías
de referencia externas.

----
include::samples/gdl-bindings.gdl[]
----

<1> Enlace del código local _gt0036 (Puntuación CHA2DS2-VASc)_ con terminología SNOMED-CT.
<2> Enlace del código local _gt0104 (Trastorno vascular)_ con terminología SNOMED-CT.
<3> Enlace del código local _gt0121 (Fibrilación auricular)_ con terminología SNOMED-CT.
<4> Enlace del código local _gt0036 (Puntuación CHA2DS2-VASc)_ con terminología CIE-10.
<5> Enlace del código local _gt0104 (Trastorno vascular)_ con terminología CIE-10.
<6> Enlace del código local _gt0121 (Fibrilación auricular)_ con terminología CIE-10.

Métodos
-------
Introducción
~~~~~~~~~~~~
Se ha optado por seguir una metodología ágil para la elaboración de este proyecto, en concreto se ha utilizado una
versión simplificada de la metodología Scrum por ser una metodología compatible con los medios disponibles para el
desarrollo de esta aplicación además de ser una metodología moderna que favorece el desarrollo rápido de aplicaciones.

Al ser una metodología ágil, se adapta perfectamente a nuestro proyecto permitiendo, mediante iteraciones, tener una
aplicación funcional al final de cada una de las mismas, haciendo posible que los requisitos y las solucionen
evolucionen con el paso del tiempo según las necesidades del proyecto

Metodología de desarrollo
~~~~~~~~~~~~~~~~~~~~~~~~~

Metodología Scrum
^^^^^^^^^^^^^^^^^
Scrum es un _framework_ de desarrollo<<SCRU12>> en el que los equipos multifuncionales desarrollan productos o
proyectos de forma iterativa e incremental. Scrum estructura el desarrollo en ciclos de trabajo  llamados _Sprints_.
Estas iteraciones no duran más de cuatro semanas cada una (lo más común son iteraciones de dos semanas), y tienen
lugar una tras otra sin pausa. Los Sprints tienen una duración determinada, terminan en una fecha específica si el
trabajo se ha completado o no, y nunca se extienden. Por lo general, los equipos Scrum eligen una longitud del Sprint
y la utilizan para todos sus Sprints hasta que mejoren y puedan utilizar un ciclo más corto. Al comienzo de cada
Sprint, un equipo multifuncional (de aproximadamente siete personas) selecciona los elementos (requisitos del
cliente) de una lista de prioridades. El Equipo acuerda un objetivo colectivo de lo que ellos creen que pueden
entregar al final del Sprint, algo que es tangible y que será verdaderamente "hecho". Durante el Sprint, no se pueden
agregar nuevos elementos, estos quedarían para el siguiente Sprint, ya que el Sprint corto actual está destinado a
centrarse en un objetivo pequeño, claro y relativamente estable. Todos los días el equipo se reúne brevemente para
inspeccionar su progreso, y ajustar los pasos siguientes necesarios para completar el trabajo restante. Al final del
Sprint, el equipo revisa el Sprint con los __stakeholders__footnote:[_stakeholder_: cualquier parte interesada que es
afectado o puede ser afectado por el desarrollo del producto], y demuestra lo que ha construido. La gente obtiene
retroalimentación que se puede incorporar en el próximo Sprint. Scrum hace hincapié en que el producto tiene que ser
funcional al final del Sprint. En el caso del software, esto significa un sistema integrado, completamente probado,
documentado para el usuario final y potencialmente enviable. Las funciones clave, artefactos y eventos se resumen en
la <<scrum-overview>>.

[[scrum-overview]]
.Scrum: visión general.
image::scrum.png[]

Un lema importante en Scrum es "inspeccionar y adaptarse". Dado que el desarrollo implica inevitablemente el
aprendizaje, la innovación y las sorpresas, Scrum hace hincapié en dar pasos cortos de desarrollo, inspeccionando
tanto el producto resultante como la eficacia de las prácticas llevadas a cabo y adaptando los objetivos del producto
y las prácticas del proceso.

Roles
+++++

En Scrum existen 3 roles: el ScrumMaster, el propietario del Producto y el Equipo. Todos juntos se les conoce como en
Equipo Scrum.

Propietario del Producto::
Es el responsable de maximizar el retorno de la inversión (ROI) identificando las
características del producto, traduciéndolas a una lista priorizada, decidiendo cuál debería estar en la parte
superior de la lista para el próximo Sprint y continuamente redefiniendo y refinando la lista. El Propietario del
Producto tiene la responsabilidad de las pérdidas y las ganancias del producto, asumiendo que es un producto comercial.
En el caso de una aplicación interna, el propietario del Producto no es responsable del ROI en el sentido de un producto
comercial (que generará ingresos), pero sigue siendo responsable de maximizar el ROI en el sentido de elegir, en cada
Sprint, los ítems de más alto valor. En la práctica, "valor" es un término difuso y la priorización puede
verse influida por el deseo de satisfacer a los clientes clave, la alineación con los objetivos estratégicos, la
minimización de riesgos, la mejora y otros factores. En algunos casos, el propietario del Producto y el cliente son
la misma persona, esto es bastante común en las aplicaciones internas. En otros casos, el cliente podría ser millones
de personas con diferentes necesidades, en cuyo caso el rol de Propietario del Producto es similar al de _Product
Manager_ o de _Product Marketing Manager_ en muchas organizaciones. Sin embargo, el Propietario del Producto es algo
diferente de un Gerente de Producto tradicional porque interactúa activamente y regularmente con el Equipo, prioriza
trabajando con todas las partes interesadas y revisando los resultados de cada Sprint, en lugar de delegar decisiones
de desarrollo a un gerente de proyecto. Es importante observar que en Scrum hay una sola persona que sirve como
Propietario del Producto, y él o ella es responsable del valor del trabajo; Aunque esa persona no tiene que trabajar
sola.

El equipo::
El Equipo, también llamado Equipo de Desarrollo, construye el producto que el Propietario del Producto
indica:
la aplicación o el sitio web, por ejemplo. El equipo en Scrum es "multifuncional", incluye toda la experiencia
necesaria para entregar el producto potencialmente en cada Sprint, y es auto-organizado, con un alto
grado de autonomía y responsabilidad. El Equipo decide cuántos artículos--del conjunto ofrecido por el Propietario
del Producto--debe construir en cada Sprint y la mejor manera de lograr ese objetivo.
+
En el Equipo no hay títulos especializados: no hay analista de negocios, ni DBA, ni arquitecto, ni jefe de equipo, ni
diseñador de interfaz gráfica, ni programador. Los componentes trabajan juntos durante cada Sprint de la manera que
sea más apropiada para alcanzar el objetivo que ellos mismos han fijado.
+
Cada persona tendrá habilidades primarias, secundarias e incluso terciarias. Los individuos también asumen tareas en
áreas en las que están menos familiarizados para ayudar a completar dicha tarea. Por ejemplo, una persona cuya
habilidad principal es el diseño de interfaces gráficas podría tener una habilidad secundaria en las pruebas
automatizadas o alguien con habilidad primaria en escritura técnica también podría ayudar con el análisis y la
programación.
+
El Equipo en Scrum consta de 5 a 9 personas. Para un producto de software el Equipo puede incluir personas con
habilidades en análisis, desarrollo, pruebas, diseño de interfaces, diseño de bases de datos, arquitectura,
documentación, etc. El equipo desarrolla el producto y proporciona ideas al Propietario del Producto sobre cómo hacer
que el producto sea de la mayor calidad posible. En Scrum los Equipos son más eficientes si todos los
miembros están dedicados a un único producto durante el Sprint. El equipo evita la multitarea a través
de múltiples proyectos, para huir de las atenciones divididas y del cambio de contexto. Los equipos estables están
asociados con una mayor productividad, por lo que es conveniente evitar cambiar a los miembros del equipo en la medida
de lo posible.

ScrumMaster::
El ScrumMaster ayuda a aplicar Scrum para producto comercial tenga éxito. Hace lo que esté en su mano para
ayudar al Equipo, al Propietario del Producto y a la organización. El ScrumMaster no es el
administrador de los miembros del equipo, ni es un jefe de proyecto, ni un líder del equipo. Ayuda a eliminar
los impedimentos que puedan surgir, protege al equipo de interferencias externas y le ayuda a adoptar
buenas prácticas de desarrollo. Educa, entrena y guía al Propietario del Producto, al Equipo y al resto de la
organización en el uso adecuado de Scrum. El ScrumMaster es un entrenador y profesor, se asegura de que
todo el mundo (incluido el Propietario del Producto y los administradores) entienda los principios y las prácticas
de Scrum. Dado que Scrum hace visibles muchos impedimentos y amenazas a la
eficiencia del Equipo y del Propietario de Producto, es importante tener un ScrumMaster comprometido trabajando
enérgicamente para ayudar a resolver dichos problemas, de lo contrario el Equipo o el Propietario del Producto es
probable que tengan dificultades para tener éxito. Un equipo pequeño podría contar con un miembro del equipo que
desempeñe este papel (llevando una carga más ligera de trabajo regular cuando lo hace). Un ScrumMaster brillante
puede provenir de cualquier disciplina: ingeniería, diseño, pruebas, gestión de productos, gestión de proyectos o
gestión de la calidad.
+
El ScrumMaster y el Propietario del Producto no pueden ser el mismo individuo, ya que su enfoque es tan diferente que
combinarlos a menudo lleva a la confusión y al conflicto. Un resultado común de combinar estos roles es un
Propietario del Producto que se opone a la autogestión de los equipos que Scrum requiere. A diferencia
de un gestor tradicional, el ScrumMaster no le dice a la gente qué hacer ni asigna tareas sino que básicamente
facilita el proceso, apoya al equipo mientras se organiza y se gestiona. Si el ScrumMaster estaba previamente en una
posición de gestión del equipo, tendrá que cambiar significativamente su mentalidad y estilo de interacción para que
el equipo tenga éxito con Scrum.
+
No hay ningún rol de líder de proyecto en Scrum, esto se debe a que no es necesario. Las responsabilidades
tradicionales de un director de proyecto se han dividido y reasignado entre los tres roles de Scrum,
y en su mayoría al Equipo y Propietario del Producto, en vez de al ScrumMaster. Utilizar Scrum con un
director de proyecto indica un mal uso fundamental de Scrum y típicamente resulta en responsabilidades
conflictivas, autoridad poco clara y resultados mejorables. A veces un ex director de proyecto puede entrar en el
papel de ScrumMaster, el éxito de este enfoque depende en gran medida de la persona, y lo bien que entienda la
diferencia fundamental entre los dos roles, tanto en las responsabilidades del día a día como en la mentalidad
necesaria para tener éxito. Una buena manera de entender a fondo el papel de ScrumMaster y comenzar a desarrollar
las habilidades básicas necesarias para el éxito, es asistir a la formación  de certificado ScrumMaster por
Scrum Alliance.

Además de estos tres roles, existen otros _stakeholders_ que contribuyen al éxito del producto como son los
administradores, los cliente y los usuarios finales. Algunos _stakeholders_ como los gerentes funcionales (_i.e._ un
gerente de ingeniería) pueden encontrarse con que su role cambia al adoptar Scrum. Por ejemplo:

* Apoyan al equipo considerando las reglas y la esencia de Scrum.
* Ayudan a eliminar los impedimentos que identifican el Equipo y el Propietario del Producto.
* Ponen a disposición sus conocimientos y experiencia.

Documentos
++++++++++
La metodología Scrum establece la elaboración de una serie de documentos para apoyar, auditar y documentar el proceso.

Product blacklog::
Cuando un grupo planea migrar a Scrum, antes de empezar el primer Sprint, se necesita el _Product Backlog_, un
documento de características centradas en el cliente priorizado y ordenado. Contiene descripciones genéricas de todos
los requisitos, funcionalidades deseables, etc. Se trata de un documento de alto nivel para todo el proyecto, que
existe y evoluciona durante la vida útil del producto. Es el plan de negocio del producto (<<product-backlog, Figura 13>>
 y <<product-backlog-visual-management, Figura 14>>). En
cualquier momento, el _Product backlog_ ofrece una visión única y definitiva de "todo lo que  podría ser hecho por el
Equipo, en orden de prioridad", esta prioridad se organiza según su retorno sobre la inversión (ROI). Sólo existe un
único _Product backlog_ para un producto, lo que significa que el Propietario del Producto debe tomar decisiones de
priorización de alto nivel, representando los intereses de todas las partes interesadas (incluido el Equipo).
+
[[product-backlog]]
.El _Product Backlog_.
image::product-backlog.png[scaledwidth="80%"]
+
[[product-backlog-visual-management]]
.Gestión visual: ítems del _Product Backlog_ sobre la pared.
image::product-backlog-visual-management.png[scaledwidth="80%"]
+
El _Product Backlog_ incluye una variedad de elementos, principalmente nuevas características del cliente
(_e.g._ "permitir a todos los usuarios colocar el libro en el carrito de compras"), pero también otros objetivos
de mejora técnica (_e.g._ "reescribir el sistema de C ++ a Java" o "Mejorar el rendimiento de los tests"),
trabajos e investigación (_e.g._ "investigar soluciones para acelerar la validación de la tarjeta de crédito"), y,
posiblemente, defectos conocidos (_e.g._ "diagnosticar y arreglar los errores del script de procesamiento de pedidos")
+
Los elementos _Product Backlog_ se expresan de cualquier manera que sea clara y concisa. Contrariamente a los
malentendidos populares, el _Product Backlog_ no contiene "historias de usuarios", simplemente contiene elementos.
Estos elementos pueden expresarse como historias de usuarios, casos de uso o cualquier otro enfoque de requisitos que
el grupo considere útil. Pero cualquiera que sea el enfoque, la mayoría de los artículos deben centrarse en la
entrega de valor a los clientes.

Sprint blacklog::
Muchos Equipos tienen un _Sprint Backlog_ en forma de tablero de tareas de tamaño de pared (a menudo llamado
también _Scrum Board_) donde las tareas, escritas en forma de notas Post-It, se van moviendo durante el Sprint a través
de las columnas denominadas "To Do", "Work In Progress" y "Done". Ver <<sprint-backlog, Figura 15>>
+
[[sprint-backlog]]
.Gestión visual: tareas de un _Sprint Backlog_ sobre la pared.
image::sprint-backlog.jpg[scaledwidth="80%"]
+
En definitiva, el _Sprint backlog_ se trata de un documento detallado donde se describe cómo el equipo va a
implementar los requisitos durante el siguiente Sprint. Las tareas se dividen en horas donde ninguna tarea
tendrá una duración superior a 16 horas. Si una tarea es mayor de 16 horas, deberá ser dividida en subtareas de un
nivel de detalle más fino. Las tareas en el _Sprint Backlog_ no se asignan, sino que los miembros del equipo las
van tomando de la manera que les parezca más oportuno.
+
Uno de los pilares de Scrum es que, una vez que el equipo establece su objetivo para el Sprint, cualquier añadido o
cambio debe ser aplazado al siguiente Sprint. Esto significa que si el Propietario del Producto, en mitad de un Sprint,
decide que hay un nuevo ítem en el que quisiera que el Equipo trabajara, no podría hacer el cambio hasta el comienzo
del próximo Sprint. Si aparece una circunstancia externa que cambia significativamente las prioridades que
significase que el Equipo estaría perdiendo el tiempo si continúa trabajando el Sprint actual, el Propietario del
Producto o el Equipo puede abortar el Sprint. El equipo se detiene y se realiza una nueva reunión de planificación
del Sprint, iniciándose de esta manera un nuevo Sprint. El perjuicio de hacer esto generalmente es grande, además de
la posible desmotivación tanto para el Propietario del Producto como para el Equipo.
+
Que el Equipo esté protegido contra los cambios durante el Sprint tiene varias ventajas. En primer lugar, el Equipo se
pone a trabajar sabiendo con absoluta certeza que su objetivo no va a cambiar, lo que refuerza el enfoque del Equipo en
asegurar la finalización. En segundo lugar, obliga al _Propietario del Producto_ a pensar realmente a través de
los ítems que él prioriza en el _Product Backlog_.

Burn Down::
La _Burn Down Chart_ es una gráfica que se muestra públicamente y que mide la cantidad de requisitos en el _Backlog_ del
proyecto pendientes al comienzo de cada Sprint. Dibujando una línea que conecte los puntos de todos los Sprints
completados, se puede ver el progreso del proyecto. Lo normal es que esta línea sea descendiente (en casos en que todo
va bien en el sentido de que los requisitos están bien definidos desde el principio y no varían nunca) hasta llegar
al eje horizontal, momento en el cual el proyecto se ha terminado (no hay más requisitos pendientes de ser
completados en el _Backlog_). Si durante el proceso se añaden nuevos requisitos la recta tendrá pendiente ascendente en
determinados segmentos, y si se modifican algunos requisitos la pendiente variará o incluso valdrá cero en algunos
tramos.

Reuniones
+++++++++
Uno de los pilares fundamentales de Scrum es la comunicación. A continuación se muestran los diferentes tipos de
reuniones que tienen lugar en esta metodología:

Daily Scrum::
El principal objetivo de las _Daily Scrum meetings_ es llevar a cabo una actualización y una coordinación entre los
miembros del Equipo. Estas reuniones son diarias durante el desarrollo de un Sprint, participan obligatoriamente
todos los miembros de el Equipo, la presencia de el Propietario del Producto es opcional y el ScrumMaster suele estar
presente. La duración máxima no debe exceder de los 15 minutos, para mantenerla breve se recomienda que todos estén
permanezcan de pie, es la oportunidad del equipo para sincronizar su trabajo e informar de cualquier obstáculo que
pudiese haber aparecido. Cada uno debe ir informando al resto del equipo de lo siguiente:

* ¿Qué se ha logrado desde la última reunión?
* ¿Qué se hará antes de la próxima reunión?
* ¿Qué obstáculos han aparecido en el camino?
+
Hay que destacar que el _Daily Scrum_ no es una reunión de estado para informar a un gerente, se trata de un tiempo para
que un equipo auto-organizado comparta entre sí lo que está pasando, se trata de una ayuda a la coordinación.

Scrum de Scrums::
Suele realizarse cada día, normalmente después del _Daily Scrum_.

* Estas  reuniones  permiten  a  los  grupos  de  equipos  discutir  su  trabajo, enfocándose especialmente en áreas de
solapamiento e integración.
* Asiste una persona asignada por cada equipo.
+
La agenda será la misma que la del _Daily Scrum_, además de las siguientes cuatro preguntas:
+
* ¿Qué ha hecho tu equipo desde nuestra última reunión?
* ¿Qué hará tu equipo antes que nos volvamos a reunir?
* ¿Hay algo que demore o estorbe a tu equipo?
* ¿Estás a punto de encargarle una tarea a otro equipo?

Sprint Planning Meeting::
Se trata de la reunión para preparar cada Sprint, típicamente dividida en dos partes, la primera se centra en el
_qué_ y la segunda en el _cómo_. En la primera parte participa el Equipo, el Propietario del Producto y el
ScrumMaster. En la segunda participa el Equipo y el ScrumMaster (el Propietario del Producto puede asistir o no, pero
debe de estar disponible por si surgiesen dudas). La duración de cada una de las partes es de una hora por semana de
Sprint. Esta reunión tiene lugar al principio de cada Sprint que, como se ha mencionado anteriormente, suelen durar
entre 1 y 4 semanas y se tratan los siguientes puntos:

* Seleccionar qué trabajo se hará exactamente.
* Preparar, con el equipo completo, el _Sprint Backlog_ que detalla el tiempo que llevará hacer el trabajo.
* Identificar y comunicar cuánto del trabajo es más probable que se pueda realizar durante el actual Sprint.
* Tiempo dedicado: ocho horas de límite.

Al final del ciclo Sprint, se llevarán a cabo dos reuniones: la _Sprint Review Meeting_ y la _Sprint Retrospective
Meeting_

Sprint Review Meeting::
En esta reunión se trata la inspección y adaptación relacionada con el incremento de funcionalidades del producto a
desarrollar. Participa el Equipo, el Propietario del Producto, el ScrumMaster y otros interesados (_stakeholders_),
según corresponda, invitados por el Propietario del Producto. La duración es de una hora por semana de Sprint.
+
Tienen lugar cuando termina el Sprint y es el momento en el que la gente hace una revisión del Sprint. La idea
principal es que esta reunión permita inspeccionar y adaptar el producto, se revisa qué trabajo fue completado y cuál
no lo ha sido. Se hace una presentación del trabajo completado a todos los interesados, no permitiéndose mostrar el
trabajo no completado. Un elemento crítico de esta revisión se centra en una _conversación_ en profundidad entre el
Equipo y el Propietario del Producto para que este último conozca la situación, reciba consejos, etc.

Sprint Retrospective::
Esta reunión es la que sigue a la _Sprint Review Meeting_, la cual se centraba en la inspección y adaptación del
producto. La _Sprint Retrospective_ se centra en la inspección y adaptación del proceso y del entorno. Participa el
Equipo, el ScrumMaster y, opcionalmente, el Propietario del Producto. Otros _stakeholders_ pueden ser invitados por
el Equipo, pero no está permitida la asistencia de nadie más.
+
En esta reunión el Equipo discute qué está funcionando y qué no lo está y se acuerdan cambios para buscar soluciones
a ciertas cosas que no funcionen. A veces, el ScrumMaster puede actuar como un coordinador eficaz para la
retrospectiva, aunque en ocasiones puede ser una mejor opción invitar a una entidad externa que sea neutral para la
coordinación de la reunión.

Fases de Scrum
^^^^^^^^^^^^^^
Se diferencian cuatro fases en el proceso de desarrollo utilizando la metodología Scrum:

Revisión de los planes de lanzamiento y distribución, revisión y ajuste de los estándares del producto::
Esta fase es llevada a cabo por los desarrolladores realizando una revisión de lo que hay que hacer y definiendo los
detalles de la revisión actual (tecnologías, estándares, etc.).

Sprint::
Es cada una de las iteraciones o cada uno de los ciclos repetitivos de trabajo similar que producen un incremento de
las funcionalidades del producto o sistema. Se trata de la fase de desarrollo que incluye análisis, el diseño, la
implementación, las pruebas, el _empaquetado_ , generación de ejecutables, etc. La duración es de entre una y cuatro
semanas, esta duración se fija a nivel global y todos los equipos que trabajan en el mismo sistema o producto
utilizan la misma duración de ciclo. En la fase de revisión se resuelven problemas y se añaden nuevos elementos y en
la fase de ajuste se utilizan las mejorías y ajustes encontrados para mejorar el producto ya se código,
documentación, etc.

Revisión del Sprint::
A veces se le denomina incorrectamente "la demo", concepto que no define la intención de esta revisión, cuyo objetivo
es revisar el producto realizado durante el último Sprint y se añadir _Backlogs_ nuevos en caso necesario. Esta fase
puede admitir la participación de los clientes, los ejecutivos, etc.

Cierre::
En esta fase se encuentran las típicas actividades de fin de proyecto dirigidas a obtener una versión distribuible,
como el _testing_, el _debugging_, la promoción, el _marketing_, etc.

Ventajas de Scrum
^^^^^^^^^^^^^^^^^
Scrum proporciona una serie de ventajas al proyecto. Debido a la filosofía de las metodologías ágiles y a las
características descritas anteriormente, dichas ventajas se pueden resumir en:

* Gestión regular de las expectativas del cliente: el cliente establece sus expectativas indicando el valor que le
aporta cada requisito del proyecto y cuándo espera que esté completado. Este puede comprobar de manera regular si se
van cumpliendo sus expectativas, y puede proporcionar _feedback_. Y es desde el inicio del proyecto cuando puede tomar
decisiones a partir de resultados objetivos y dirigirlos iteración a iteración hacia su meta. Se ahorran esfuerzos y
tiempo al evitar las posibles hipótesis.

* Resultados anticipados (_time to market_): el cliente puede empezar a utilizar los resultados más importantes del
proyecto antes de que este haya finalizado por completo. Siguiendo la ley de Pareto (el 20% del esfuerzo proporciona
el 80% del valor), el cliente puede empezar antes a recuperar su inversión (y/o autofinanciarse) comenzando a
utilizar un producto al que sólo le faltan características poco relevantes, puede sacar al mercado un producto antes
que su competidor, puede hacer frente a urgencias o nuevas peticiones de clientes, etc.

* Flexibilidad y adaptación: de manera regular el cliente redirige el proyecto en función de sus nuevas prioridades,
de los cambios en el mercado, de los requisitos completados que le permiten entender mejor el producto, de la
velocidad real de desarrollo, etc. Al final de cada iteración el cliente puede aprovechar la parte de producto
completada hasta ese momento para hacer pruebas de concepto con usuarios o consumidores y tomar decisiones en función
del resultado obtenido.

* Retorno de inversión (ROI): de manera regular, el cliente maximiza el ROI del proyecto. Cuando el beneficio
pendiente de obtener es menor que el coste de desarrollo, el cliente puede finalizar el proyecto.

* Mitigación de riesgos: desde la primera iteración el equipo tiene que gestionar los problemas que pueden aparecer
en una entrega del proyecto. Al hacer patentes estos riesgos, es posible iniciar su mitigación de manera anticipada.
"Si hay que equivocarse o fallar, mejor hazlo lo antes posible". El _feedback_ temprano permite ahorrar esfuerzo y
tiempo en errores técnicos. La cantidad de riesgo a que se enfrenta el equipo está limitada a los requisitos que se
pueden desarrollar en una iteración. La complejidad y riesgos del proyecto se dividen de manera natural en iteraciones.

* Productividad y calidad: de manera regular el equipo va mejorando y simplificando su forma de trabajar. Los
miembros del equipo sincronizan su trabajo diariamente y se ayudan a resolver los problemas que pueden impedir
conseguir el objetivo de la iteración. La comunicación y la adaptación a las diferentes necesidades entre los
miembros del equipo son máximas (se van ajustando iteración a iteración), de manera que no se realizan tareas
innecesarias y se evitan ineficiencias.
+
Las personas trabajan más enfocadas y de manera más eficiente cuando hay una fecha límite a corto plazo para entregar
un resultado al que se han comprometido. La consciencia de esta limitación temporal favorece la priorización de las
tareas y fuerza la toma de decisiones. Las iteraciones (Sprints) son regulares y de un mes para facilitar la
sincronización sistemática con otros equipos, con el resto de la empresa y con el cliente. El Equipo minimiza su
dependencia de personas externas para poder avanzar (depender de la disponibilidad de otros puede parar o
retrasar tareas).
+
La estimación de esfuerzo y la optimización de tareas para completar un requisito es mejor si la realizan las
personas que van a desarrollar el requisito, dadas sus diferentes especializaciones, experiencias y puntos de vista.
Asimismo, con iteraciones cortas la precisión de las estimaciones aumenta. Las personas también trabajan de manera más
eficiente y con más calidad cuando ellas mismas se han comprometido a entregar un resultado en un momento determinado
y deciden cómo hacerlo, no cuando se les ha asignado una tarea e indicado el tiempo necesario para realizarla. El
Equipo evita ocupar mucho tiempo en tareas que sigan un camino equivocado, que le obligue a realizar un gran esfuerzo
para llegar al objetivo esperado. Se asegura así, la calidad del producto de manera sistemática y objetiva, a nivel
de satisfacción del cliente, requisitos listos para ser utilizados y calidad interna del producto.

* Alineamiento entre cliente y Equipo: los resultados y esfuerzos del proyecto se miden en forma de objetivos y
requisitos entregados al negocio. Todos los participantes en el proyecto conocen cuál es el objetivo a conseguir. El
producto se enriquece con las aportaciones de todos.

* Equipo motivado: las personas están más motivadas cuando pueden usar su creatividad para resolver problemas y
cuando pueden decidir organizar su trabajo. Las personas se sienten más satisfechas cuando pueden mostrar los logros
que consiguen.

Aplicación de Scrum en el proyecto
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Como ya se ha comentado al principio de esta sección, se ha utilizado una versión simplificada de la metodología Scrum.

Esta versión simplificada consiste en la realización de iteraciones bien diferenciadas y que permiten ir obteniendo
un producto de desarrollo operativo al final de cada una. Se han realizado cuatro iteraciones, en las cuales, al final
de cada una de ellas, se obtiene un subproducto funcional de la aplicación final. En la primera iteración se obtiene
una aplicación con la funcionalidad básica; se crea la estructura del proyecto AngularJS y se desarrolla la
funcionalidad que muestra las guías clínicas que existen en el sistema, de modo que el usuario pueda seleccionar una
para su edición. En la segunda iteración se comienza el desarrollo de la edición de las guías, permitiendo la
gestión de la descripción de las mismas (meta-información) y de  la definición de los elementos de las guías, que
provienen de los arquetipos clínicos. La iteración 2 complementa a la 1 y permite tener un subsistema con una
funcionalidad más avanzada. La tercera iteración se ha centrado en la edición de las reglas GDL, posibilitando la
creación y eliminación de nuevas reglas y la gestión de las condiciones y de las acciones de cada una. En esta misma
iteración, por similitud funcional también se ha tratado la edición de las precondiciones de las guías. En la última
iteración se finaliza la edición aumentando la funcionalidad, es decir, en esta iteración se ha abarcado la
funcionalidad que permite la edición de los términos locales, el agregado de los mismos, la edición de enlaces a
terminologías externas y la visualización del código GDL generado en un editor de textos, así como una vista en
formato HTML con información tanto de autoría como clínica de las guías. En esta última iteración se ha desarrollado
también la funcionalidad de salvado de las guías en el _backend_ y de creación de una nueva guía clínica,
obteniéndose de este modo la aplicación global completamente terminada y funcional.

Otra particularidad que caracteriza a esta versión simplificada de Scrum es la analogía en cuanto a las reuniones. Se
han realizado reuniones periódicas entre el ScrumMaster, en este caso el director profesional del proyecto, y el
Equipo, en este caso mi persona, como alumno que realiza el proyecto. No se han realizado _Daily Scrum meetings_ por
motivos laborales, pero sí se han realizado reuniones siempre de la misma duración y en la medida de lo posible en el
mismo lugar (en su defecto se han llevado a cabo mediante sesiones remotas de Skype). En estas reuniones se trataron los
asuntos referentes a qué se ha hecho (y cómo), los problemas que hubiesen podido surgir y qué se pretendía hacer hasta
la siguiente reunión. En cada iteración se describieron las tareas a llevar a cabo dependiendo de la fase en la que
se encontrase el proyecto de acuerdo a la iteración vigente. Al terminar cada iteración hemos procedido a la revisión
de la misma, donde se ha analizado el grado de cumplimiento de los objetivos planteados para dicha iteración,
realizando los cambios pertinentes en caso de que fueran necesarios. La misma persona que el ScrumMaster ha jugado
el papel de cliente, ya que conoce a la perfección las necesidades que existen en la plataforma de __open__EHR donde
se pretende implantar este proyecto.

Por lo tanto, se han aplicado las principales características de Scrum como la realización por iteraciones con un
producto operativo al final de cada una de ellas, las revisiones periódicas y la toma de decisiones sobre el
desarrollo guiado por las reuniones regulares por parte de las partes implicadas en el desarrollo de este proyecto.

Desarrollo
----------
La fase de desarrollo de este editor de guías clínicas se ha llevado a cabo en cuatro iteraciones o Sprints de Scrum,
obteniéndose al final de cada una de ellas una aplicación funcional y operativa. Cada iteración se corresponde con
varias de las funcionalidades que representan los caso de uso y consta de una fase de análisis, una de diseño, una de
implementación y una de pruebas. Siguiendo la metodología Scrum, ha habido una reunión de planificación antes del
primer Sprint para decidir el orden de las funcionalidades a desarrollar en cada iteración. A mayores nos hemos reunido
antes de empezar cada Sprint para decidir los componentes a desarrollar durante el mismo.

A continuación se muestra un diagrama de despliegue de alto nivel, que ayuda a situar cada componente de los que se
mencionan en esta memoria:

[[deployment]]
.Diagrama de despliegue del sistema.
image::deployment.png[scaledwidth="80%"]

Iteración 1
~~~~~~~~~~~
En la primera iteración se ha establecido el objetivo básico de tener una primera versión funcional para
posteriormente, ir añadiéndole el resto. De modo que lo que se pretendió llevar a cabo en este Sprint fue la decisión de
la estructura de directorios de la aplicación y el desarrollo de permitir visualizar las guías clínicas existentes.

Análisis
^^^^^^^^
En la fase de análisis del primer Sprint se han identificado dos tareas a ser tratadas. Por un lado se ha
analizado la estructura organizativa de directorios de la aplicación y por otro el desarrollo de la funcionalidad
básica consistente en la visualización de las guías clínicas existentes en el _backend_.

Para la primera tarea, se ha estudiado la mejor mejor forma de estructurar la aplicación web. En numerosas ocasiones, en
las primeras fases de un proyecto AngularJS, la estructura de directorios no importa demasiado y se tiende a ignorar
las guías de buenas prácticas dedicadas a este cometido. Si se trata de una aplicación pequeña, esto no tendría
importancia y permitiría al desarrollador tener algo funcional rápidamente, no afectando en ningún sentido a la
aplicación. Pero si se trata de un proyecto mediano o grande con algo que complejidad, esto afectaría a la capacidad
de mantenimiento de la aplicación. AngularJS es todavía relativamente nuevo y los desarrolladores aún están
averiguando cuál es la mejor forma de estructurar una SPA. Hay muchas maneras de estructurar una aplicación, se han
tomado algunos principios de los _frameworks_ MVC maduros existentes, pero también hemos tomado algunas cosas que son
específicas de Angular.

Para construir aplicaciones que sean escalables y mantenibles en AngularJS se debe hacer uso de las guías de buenas
prácticas existentes a tal efecto. La estructura de una aplicación Angular ideal debe ser modularizada en
funcionalidades específicas. Se deben aprovechar las extraordinarias directivas de AngularJS para compartimentar aún
más nuestras aplicaciones. Las estructuras donde se usa un directorio por funcionalidad se dice que siguen el
principio LIFTfootnote:[*LIFT:* L-Localización del código sencilla, I-Identificación del código de un vistazo,
F-Aplana la estructura lo máximo posible (F de 'flatten') y T-Tratar de no repetir código.]. Esta aproximación es la
adecuada para proyectos que no sean pequeños, aportando una serie de beneficios como los siguientes:

* Mantenibilidad del código: seguir este enfoque estructurando lógicamente las aplicaciones permite localizar y
editar el código de una manera sencilla.

* Escalabilidad: la aplicación será mucho más escalable. Agregar nuevas directivas y plantillas no incrementará las
carpetas existentes. La incorporación de nuevos desarrolladores también debería ser mucho más fácil una vez que se
aplica esta aproximación. Además, con este enfoque, se podrán añadir y eliminar funcionalidades de la aplicación con
relativa facilidad de manera que testear nuevas funcionalidades debería ser bastante sencillo.

* Depuración: con esta aproximación modularizada es mucho más fácil depurar el código. Facilita encontrar las piezas
de código erróneo y solucionar dichos errores.

* Pruebas: escribir tests unitarios y probar aplicaciones modularizadas es mucho más sencillo que las no modularizadas.

La segunda tarea de esta iteración se ha centrado en la funcionalidad básica consistente en la visualización de todas
 las guías clínicas existentes para que se puedan seleccionar individualmente y, a partir de ahí, las guías puedan
 ser modificadas. Esta tarea se ha limitado a la visualización del listado de guías  clínicas almacenadas en el
 _backend_. Para que esto sea posible, el caso de uso (ver <<use-cases-iter-1>>) que se ha de implementar es el que
 permita navegar entre las guías clínicas (_Browse clinical guidelines_), el cual se describe a continuación.

Descripción de los casos de uso
+++++++++++++++++++++++++++++++
A continuación se describe el caso de uso _Browse clinical guidelines_.

Navegar guías clínicas::
Para que el profesional sanitario pueda editar un guía clínica existente, primero debe poder visualizar las guías que
ya están creadas. Cuando se muestre el listado con las guías, el usuario simplemente seleccionará la que desee editar.

Diseño
^^^^^^
Una aplicación profesional debe ir acompañada siempre de una documentación de modelado técnico y funcional hasta un
cierto nivel de detalle, _i.e._ no demasiado detallado. El diseño debe ser suficiente para posteriormente encontrar
más detalles en el código fuente. Si el código fuente aún no ha sido escrito, el diseño debe ser suficiente para que
el desarrollador rellene los detalles a su propia discreción. Esta documentación permite ahorrar tiempo (y por lo
tanto, dinero) y permite que los usuarios obtengan una aplicación de mayor calidad. El ahorro surge del hecho de que
el diseño proporciona una visión de la estructura del software y por lo tanto reduce la posibilidad de una mala
organización (_spaghetti code_, inconsistencias, código duplicado). Esta visión general de la estructura del software
permite disminuir:

* La posibilidad de cometer errores y, en consecuencia, el tiempo que se tarda en resolver dichos errores.
* El tiempo que se tarda en determinar la mejor manera de integrar un cambio o extensión en particular.
* El tiempo que se tarda en corregir defectos en la estructura más adelante.

En la fase de diseño de la primera iteración hemos realizado el diseño básico de toda la aplicación, esto conlleva
los principales diagramas orientados a las funcionalidades generales.

En un editor de guías clínicas las funciones básicas que se deben poder realizar son las de crear una guía clínica
desde el principio y el de poder navegar entre las guías existentes para poder seleccionar una y modificarla. Los
casos de uso que se han de implementar son los siguientes:

[[use-cases-iter-1]]
.Casos de uso de la aplicación.
image::use-cases-iter-1.png[scaledwidth="80%"]

El único actor que tenemos en este desarrollo es el de _Profesional Sanitario_ que, como conocedor del dominio médico,
será el que elabore las guías clínicas.

Se ha dedicado una iteración para cada uno de los casos de uso que extienden del caso de uso base _Editar guía
clínica_, por lo que la explicación de cada uno de ellos se indicara en la iteración correspondiente. La creación de
una guía nueva se entiende como la edición de una guía con sus secciones vacías, excepto las obligatorias (ver
<<_paquete_de_guias_clinicas>>), que se rellenarán en el proceso que implementa el caso de uso _Crear nueva guía
clínica_.

Como se ha comentado en la <<_modulos_en_angularjs>>, la arquitectura de alto nivel de una aplicación AngularJS se
estructura en módulos, de tal manera que lo natural es comenzar el diseño creando un diagrama que represente los
módulos de la aplicación. El símbolo pertinente de UML para representar un  módulo es el paquete (_package_). Para
dejar su significado absolutamente claro, se ha estereotipado el paquete como _\<<module>>_.

[[architecture]]
.Arquitectura de alto nivel.
image::architecture.png[]

Las flechas son asociaciones de dependencia y se corresponden con las dependencias definidas en el código bien en el
método `module` del objeto `angular` o bien en los propios objetos definidos en cada uno de los módulos. A
continuación se describen los módulos definidos entrando un poco más en detalle e indicando el propósito y las
responsabilidades de cada uno:

* `app`: es el módulo raíz de la aplicación. Se le pasa a la directiva https://docs.angularjs.org/api/ng/directive/ngApp[ngApp]
para lo cargue en el https://docs.angularjs.org/api/auto/service/$injector[$injector] cuando se inicia la aplicación
AngularJS. Debe contener todo el código necesario para que la aplicación pueda funcionar o tener las dependencias
sobre otros módulos que contengan dicho código.

* `app.services`: módulo que contiene los servicios personalizados de la aplicación. La idea básica de los servicios
es agrupar funcionalidad que permita posteriormente ser utilizada en los controladores, mejorando la claridad y
favoreciendo la reutilización del código.

* `app.controllers`: módulo que contiene los controladores personalizados de la aplicación. Se responsabilizan de
proporcionar a la aplicación el comportamiento que soporte un marcado declarativo en la vista (plantilla HTML).

* `app.directives`: módulo que contiene las directivas personalizadas de la aplicación. En AngularJS cualquier acción
que requiera modificar los elementos del DOM deben hacerse a través e una directiva.

* `app.components`: módulo que contiene los componentes personalizados de la aplicación, son un tipo especial de
directiva que utilizan una configuración más simple que lo hace más adecuado para una aplicación con una estructura
basada en componentes. Estos componentes son auto-contenidos, por lo que son reutilizables en diferentes puntos de la
aplicación, fomentando las buenas prácticas del desarrollo de aplicaciones web.

* `app.constants`: módulo que contiene las constantes globales personalizados de la aplicación. Proporciona una
manera de inyectar valores constantes en cualquier controlador o servicio que lo necesite.

* `app.filters`: módulo que contiene filtros personalizados de la aplicación. Se usan en la vista, controladores o
servicios para formatear los datos a mostrar en la vista. En esta aplicación web no se han utilizado en los
servicios, motivo por el cual no existe una dependencia en el diagrama de la <<architecture>>.

* `ui`: módulo que actúa como contenedor de los 4 siguientes. Se han agrupado en este debido a la relación de sus
funcionalidades con la interfaz de usuario.

* `ui.tree`: componente de _drag and drop_ que permite anidación en forma de árbol, utilizado en la definición de los
elementos de los arquetipos, en la definición de los predicados, en las reglas y en las pre-condiciones de las guías
clínicas.

* `ui.codemirror`: componente que facilita un área de texto, numerada, donde se permite editar la guía en formato GDL.

* `ui.router`: solución _de facto_ para el enrutado de vistas en _Single Page Applicactions_. Este tipo de enrutado
modela las aplicaciones como un árbol de estados jerárquico, cada estado se corresponde con una vista con su
correspondiente controlador. Proporciona una https://en.wikipedia.org/wiki/Finite-state_machine[máquina de estados]
que permite gestionar las transiciones entre dichos estados.

* `ui.bootstrap`: componente con un conjunto de directivas AngularJS nativas basadas en el marcado de Bootstrap y en
CSS.

* `xEditable`: componente utilizado para la edición de tablas requerido en la sección de terminologías.

* `ngSanitize`: componente utilizado para evaluar como una expresión un HTML que proviene del _backend_ e insertarlo
de forma segura en el elemento correspondiente de la vista. Se utiliza en la vista HTML de la guía clínica.

* `treeControl`: módulo utilizado para la gestión de los árboles de la aplicación, utilizado en diferentes situaciones.

Para inicializar la aplicación AngularJS y declarar las dependencias mencionadas anteriormente lo hacemos a través un
fichero en el que definimos el módulo principal (ver la sección <<_modulos_en_angularjs, módulos en AngularJS>>), a
este fichero  le hemos llamado `app.js` y su contenido es el siguiente:

----
include::../../app/app.js[]
----

La funcionalidad básica que se trató de llevar a cabo en esta primera iteración fue la de permitir mostrar las guías
clínicas de manera que, en siguientes iteraciones, esta lista permitiese la navegación entre las mismas. El siguiente
diagrama de secuencias muestra la forma en la que diferentes componentes se comunican entre sí para cumplir esta tarea:

[[sequence-guidelines]]
.Diagrama de actividades: listado guías clínicas.
image::sequence-guidelines.png[]

Se diferencian 3 colores en los componentes implicados en las diferentes líneas de vida del diagrama de la
<<sequence-guidelines>>: amarillo para los desarrollados para la aplicación, azul para los que son nativos de AngularJS
y en gris está representado el _backend_. Cuando se selecciona la pestaña _Guidelines_ (ver <<_manual_de_usuario,
manual de usuario>>), el enrutador de Angular automáticamente carga el controlador correspondiente (_GuidelinesCtrl_),
al cual se le inyecta el servicio _guidelinesFactory_. Este controlador cuenta con un método _activate()_ que es
invocado al iniciarse y que llama al método _getGuidelines()_ del servicio inyectado, el cual hace uso del servicio
nativo de AngularJS `$http`, que hace una petición GET a la API del <<X4, Knowledge Manager>> (KM), el cual
gestiona dicha petición y devuelve una promesa, que se renderizará cuando dicha petición se haya completado.

Implementación
^^^^^^^^^^^^^^
Como se ha comentado en la <<_analisis, sección de análisis>> se ha optado por seguir una aproximación LIFT para la
estructura de directorios del proyecto.

----
app/
--- assets/                     // Recursos para la aplicación
------ css/                     // Ficheros relacionados con los estilos
------ img/                     // Imágenes e iconos de la aplicación
------ mocks/                   // Mocks utilizados para los tests unitarios, como respuestas de servicios web
--- components/                 // Cada componente se trata como una mini-aplicación AngularJS
------ common/
------ expression-editor/
------ layout/
------ modals/                  // Los modales de la aplicación, como componentes reutilizables
------ tabs/                    // Cada una de las principales funcionalidades del editor
--------- tab-binding/
--------- tab-definitions/
--------- tab-description/
--------- tab-gdl/
--------- tab-guidelines/
--------- tab-html/
--------- tab-preconditions/
--------- tab-rulelist/
--------- tab-terminology/
--------- tabs.component.html
--------- tabs.component.js
--------- tabs.component.spec.js
------ version/
--- config/
------ constants.js
------ http.js
------ routes.js                // Enrutado, para que la SPA no tenga que recargar la página entera durante la navegación
--- lib/
--- app.js
--- index.html
docs/                           // Documentación de la aplicación
--- output/
--- source/
--- diagramas.astah
e2e-tests/                      // Tests end-to-end
--- protractor.conf.js
--- scenarios.js
bower.json
package.json
----

El esquema anterior muestra una aproximación modularizada para construir aplicaciones AngularJS. Para la
implementación de la primera iteración vamos a detallar los componentes que se han desarrollado para implementar la
funcionalidad del listado de guías clínicas, así como los principales ficheros tanto de configuración como los
necesarios para arrancar un proyecto Node.js y una aplicación AngularJS, excluyendo todo lo relacionado con las
pruebas, que se verán en la siguiente sección.

En primer lugar, cabe mencionar el fichero de configuración de Node.js, denominado _package.json_. Ofrece un modo
eficiente de administrar los paquetes _npm_ footnote:[Node Package Management: https://www.npmjs.com/] instalados
localmente, entre otras funciones se destacan las siguientes:

* Sirve de documentación para los paquetes de los que depende un proyecto.
* Permite especificar las versiones de un paquete que su proyecto puede utilizar usando reglas de versionado
semánticofootnote:[Versionado semántico: http://semver.org/].
* Hace su compilación reproducible, lo que se traduce en una manera más sencilla de compartir con otros desarrolladores.

A continuación se muestra la estructura del _package.json_ del proyecto.

----
include::../../package.json[]
----

Este fichero, como mínimo tiene que tener los campos _name_ y _version_, con el nombre y la versión del proyecto
respectivamente. Al establecer _private_ como 'true', _npm_ se negará a publicarlo, esto impide
que se publique accidentalmente en el registro público de _npm_, en _description_ se indica una descripción clara y
concisa del proyecto, _author_ para el autor principal del proyecto. _repository_ se utiliza para especificar la URL y
el tipo de repositorio del código fuente, esto es útil para las personas que quieren contribuir a su módulo. Se usa el
campo _license_ para indicar bajo qué licencia se ha lanzado el código. Bajo _devDependencies_ se indican las
dependencias que sólo se destinan al desarrollo y pruebas del módulo. Por último, se tiene un campo _scripts_ que
consta de un objeto que expone comandos adicionales de _npm_, se asume que la clave es el comando _npm_ y el valor es
el _path_ del script, por ejemplo, para iniciar el servidor web de desarrollo ejecutamos `npm start`.

Como gestor de dependencias para el desarrollo web _frontend_ se ha utilizado Bowerfootnote:[Sistema de gestión de
paquetes: https://bower.io/]. Se cuenta con un fichero _bower.json_ donde se especifican las dependencias del
proyecto, de modo que se le pueda pedir a Bower que las instale o actualice todas de una vez, si es que se encuentran
versiones nuevas que interese que se instalen. También, al subir a producción un proyecto, permite aprovisionarlo con
todas las librerías externas necesarias. Este archivo es muy fácil de construir, con sintaxis JSON, indicando una
serie de campos que se necesitan para la definición de un proyecto y sus dependencias. A continuación se muestra el
fichero _bower.json_.

----
include::../../bower.json[]
----

El formato es similar al _package.json_, sin embargo en el _bower.json_ indicamos las dependencias de terceros que
se han utilizado para el _frontend_, mientras que en el _package.json_ se gestionan los módulos de Node.js. Para
instalar las dependencias del _frontend_ no es necesario ejecutar `bower install` a mano ya que se ha creado un
script en el _package.json_ (denominado `postinstall`) que lo hará automáticamente una vez iniciado el servidor web
Node.js.

Para gestionar la navegación de la aplicación entre las diferentes vistas se ha utilizado el módulo `ui-router`, el
cual permite cargar varias vistas simultáneamente en una misma página. El patrón https://tiles.apache.org/framework/tutorial/pattern.html[Composite View]
es uno de los clásicos a la hora de desarrollar la capa de presentación y define que la vista puede estar compuesta
por varias subvistas que se actualizan de forma independiente.

.Patrón _Composite View_.
image::composite-view.png[scaledwidth="50%"]

Para configurar AngularJS para que utilice el módulo `ui-router` lo registramos como dependencia del proyecto, tal
como se ha mostrado en la sección anterior. El módulo en cuestión es el `ui.router` y se apoya en el concepto de
_estado_ para definir la navegación entre vistas:

* Un _estado_ se corresponde a un "lugar" en la aplicación en términos de la interfaz de usuario general y de la
navegación.
* Un _estado_ (a través de las propiedades controlador / plantilla / vista) describe lo que muestra la interfaz de
usuario y lo que se hace en ese lugar.
* Los _estados_ tienen a menudo cosas en común, y la manera de refactorizar estos puntos en común en
este modelo se hace a través de una jerarquía de estados.

El enrutado de la aplicación se ha definido en el fichero `routes.js`, cuyo contenido se muestra a continuación:

[source, python]
----
angular.module('app')
  .config(function ($stateProvider, $urlRouterProvider) {
      $urlRouterProvider.otherwise("/tabs/tab-guidelines");
      $stateProvider
        .state("tab-guidelines", {
          url: "/tab-guidelines",                                                   <1>
          templateUrl: "components/tabs/tab-guidelines/tab-guidelines.html",        <2>
          controller: "GuidelineCtrl",                                              <3>
          controllerAs: "vm"                                                        <4>
        })
  });
----
<1> _path_ asociado al estado _tab-guidelines_.
<2> Plantilla (vista HTML) asociada a dicho estado.
<3> Controlador vinculado al estado en cuestión,
<4> Sintaxis que proporciona un código más claro en los controladores.

El módulo `ui-route` proporciona, entre otros, los servicios usados en el listado anterior, _i.e._ `$stateProvider` y
`$urlRouterProvider`. El primero nos permite dar nombres a las rutas. Entre otras cosas, permite a cada estado
asignarle un _path_, una vista y un controlador, de tal manera que, cuando se active dicho estado, renderizará su
vista correspondiente, con su controlador y su `$scope` de manera aislada garantizando de este modo un bajo
acoplamiento entre las vistas. Para esta primera iteración, solamente tendremos un estado que define la primera de
las pestañas donde se muestran todas las guías clínicas y se le permite al usuario seleccionar una de ellas.

Una vez mencionados los principales ficheros a tener en cuenta a nivel de proyecto, ahora nos centramos en los
relacionados en la tarea de _Navegar guías clínicas_ dedicada a esta iteración. Cuando se activa un _estado_ su vista
 asociada se inserta automáticamente en la directiva `ui-view` de la plantilla asociada a su estado padre, con la
 excepción de que si es un estado de primer nivel, la plantilla (o vista) de su estado padre es `index.html`.

En `index.html` se cuenta con dos https://docs.angularjs.org/guide/component[componentes], uno que define un panel
que indica la guía seleccionada y otro que define un conjunto de pestañas donde, cada una de ellas, va a permitir crear,
editar o eliminar ciertas características de las guías clínicas.

[source,html]
----
<div class="container-fluid">
  <gdl-panel></gdl-panel>
  <gdl-tabs></gdl-tabs>
</div>
----

El componente `tabs.component.js` contiene la directiva `ui-view` donde se insertarán cada una de las pestañas que
permiten editar las guías. Las guías tienen que mostrarse en la vista que se cargue al iniciar la aplicación, que es
la que está asociada con el _estado_ anteriormente definido (_tab-guidelines_). Este estado hace que se cargue la
vista correspondiente en dicha pestaña, a continuación se muestra la vista y el controlador asociados a dicho estado.

[source,html]
----
include::../../app/components/tabs/tab-guidelines/tab-guidelines.html[]
----

Tal como indica el `routes.js`, esta vista tiene asociado un controlador con un _scope_ delimitado a la propia vista.
Este controlador se llama `GuidelineCtrl` y es definido en `tab.guidelines.controller.js`, a continuación se muestra
dicho controlador.

[source,python]
----
include::../../app/components/tabs/tab-guidelines/tab.guidelines.controller.js[]
----

En este controlador es donde definimos las propiedades que estarán enlazadas con la vista, en este caso `vm
.guidelines` que contendrá las guías almacenadas en el _backend_. Para hacer la petición de las guías, a este
controlador se le inyecta un servicio (`guidelinesFactory`), que se ha definido _a priori_, que es el encargado de
realizar la petición correspondiente a la API REST proporcionada por el Knowledge Manager (KM). Como vemos a
continuación, este servicio cuenta con un método `getGuidelines()` que recupera las guías clínicas.

[source,python]
----
include::../../app/components/tabs/tab-guidelines/tab.guidelines.service.js[]
----

A su vez, este servicio, hace uso de los servicios nativos de Angular `$http` y `$q`. El primero se usa para la
comunicación con servidores HTTP remotos y el segundo para la ejecución de funciones asíncronas y la utilización de
los valores devueltos por dichas funciones. Se trata de una implementación compatible con https://promisesaplus.com/[Promises/A+],
una implementación de promesas/objetos diferidos basado en https://github.com/kriskowal/q[Q de Kris Kowal].

Lo que se ha obtenido en esta primera iteración es la definición de la estructura global del proyecto y la
funcionalidad básica de la primera vista. En siguientes iteraciones, por tratarse de funcionalidades más complejas se
omitirán capturas de código de servicios y controladores. Después de esta iteración, un usuario tiene la posibilidad
de visualizar las guías contenidas en el servidor.

.Iteración 1: funcionalidad visualización guías clínicas.
image::iteration-1.png[]

Pruebas
^^^^^^^
Una explicación más general sobre las tecnologías que se han utilizado para los tests de este proyecto se pueden ver
en la <<testing>>.

Es esta sección nos centraremos en los tests de cada una de las iteraciones, comenzando por la
configuración necesaria para la ejecución de los tests. Como se ha mencionado, para los tests unitarios se ha
utilizado el _testrunner_ Karma, el cual necesita un fichero de configuración denominado `karma.conf` y que tiene que
estar en el directorio raíz del proyecto. A continuación se muestra el contenido de dicho fichero para nuestro proyecto.

[source,python]
----
include::../../karma.conf.js[]
----

En la configuración se pueden observar diferentes elementos que requieren mención. `basePath` se utiliza para indicar
una ubicación de la ruta raíz que será usada para resolver todas las rutas relativas definidas en los patrones, como
por ejemplo ficheros (_files_), exclusiones (_exclude_), etc. `files` es un array que contiene todos los ficheros
necesarios para ejecutar un test, son los ficheros (o los patrones) que se cargarán en el navegador. `autoWatch` se
utiliza para habilitar o deshabilitar la auto-observación de ficheros, de tal modo que los tests se estén ejecutando
continuamente cada vez que se guarda un fichero. `frameworks` es un array que contiene la lista de _frameworks_ de
tests que se quieren utilizar, en nuestro caso sólo utilizaremos el framework Jasminefootnote:[_Framework_ de tests
open source para AngularJS: https://jasmine.github.io/]. En `browsers` se indica una lista de navegadores para
iniciar y capturar. Cuando Karma se inicia, también se iniciará cada navegador que se indique dentro de este elemento.
Una vez que Karma se cierre, también cerrará estos navegadores. Puede capturar manualmente cualquier navegador
abriendo el navegador y visitando la URL donde está escuchando el servidor web Karma
(por defecto es http://localhost:9876/). El ajuste `plugins` se utiliza para indicar una lista de plugins a cargar
(ver http://karma-runner.github.io/1.0/config/plugins.html[plugins] para más información). Por último,
`junit-reporter` es uno de los plugins cargados donde le indicamos donde queremos que nos almacene los informes
generados.

Para la primera iteración se han realizado tests unitarios para comprobar que tanto el controlador como el servicio
hacen lo que tienen que hacer, así como un test _end-to-end_ sencillo que se asegura que el enrutado está funcionando
correctamente.

Testeando el controlador `tab.guidelines.controller.js`
+++++++++++++++++++++++++++++++++++++++++++++++++++++++
A continuación se detalla el procedimiento de pruebas para el controlador `tab.guidelines.controller.js` que se ha
utilizado para la obtención de las guías clínicas. La librería `angular-mocks` que se ha añadido en el fichero `karma.conf`
proporciona un servicio llamado `$controller` que se puede utilizar para testear un controlador. En el
`beforeEach()` que se muestra más abajo, se inyecta el servicio `$controller` con las dependencias necesarias para
instanciar dicho controlador. Siguiendo la guía de buenas prácticas, al fichero que contiene los tests unitarios para
testear el controlador `tab.guidelines.controller.js` le hemos llamado `tab.guidelines.controller.spec.js`

[source,python]
----
include::../../app/components/tabs/tab-guidelines/tab.guidelines.controller.spec.js[]
----

En el anterior test se comprueban varias cosas, por un lado que la inicialización del controlador se hace
correctamente, obteniéndose un array vacío en las guías antes de la ejecución del método `getGuidelines()` y que el
mensaje de error en caso de fallo sea igual a `false`. Por otro lado se comprueba que el método `getGuidelines()`
funciona correctamente, tanto si obtienen las guías de forma satisfactoria (`deferred.resolve`) como que se muestra el
mensaje de error correspondiente cuando, por algún motivo, se ha producido un error (`deferred.reject`).

Testeando el servicio `tab.guidelines.service.js`
+++++++++++++++++++++++++++++++++++++++++++++++++
A continuación se detalla el procedimiento de pruebas par el servicio `tab.guidelines.service.js`, que hace una
petición HTTP para obtener las guías clínicas disponibles en el servidor. Siempre que se utiliza el servicio nativo
`$http` para hacer una llamada remota, Angular utiliza por detrás otro servicio llamado `$httpBackend` que es el que
realmente hace el trabajo duro. La librería `angular-mocks` que se ha añadido al fichero `karma.conf` cuenta con su
propia versión de `$httpBackend` con ciertas ventajas que nos ayudan a simular llamadas al _backend_ real. Siguiendo
la guía de buenas prácticas, al fichero que contiene los tests unitarios para testear el servicio `tab.guidelines.service.js`
le hemos llamado `tab.guidelines.service.spec.js`

[source,python]
----
include::../../app/components/tabs/tab-guidelines/tab.guidelines.service.spec.js[]
----
En el anterior test se comprueban varias cosas, por un lado que la inicialización del servicio no es `undefined`. Si
se llama a `getGuidelines()` desde el test, hará una petición HTTP real al _endpoint_ indicado. Sin embargo, lo que
hacemos es interceptar dicha llamada con `$httpBackend` y definimos la respuesta en vez de hacer la llamada remota real.
Obsérvese que es necesario hacer `$httpBackend.flush()` ya que la llamada `$http` normalmente es asíncrona, pero en
el test lo queremos ejecutar de forma síncrona. La llamada a `flush()` asegura que el `.then()` de la promesa
devuelta por `$http` sea ejecutada inmediatamente.

Iteración 2
~~~~~~~~~~~
En la primera iteración se desarrolló la funcionalidad básica de mostrar un listado con las guías clínicas
disponibles. En la segunda iteración se busca acometer el desarrollo de dos funcionalidades: por un lado la edición
de la descripción de las guías y por otro la edición de las definiciones.

Análisis
^^^^^^^^
Para cumplir los objetivos marcados para esta segunda iteración, se implementan los casos de uso _Editar descripción_ y
_Editar definiciones_ de una guía clínica. Para ello se hace un refinamiento de ambos casos de uso, estudiándolos con
un nivel de detalle más fino.

[[use-case-desc-2]]
Descripción de los casos de uso
+++++++++++++++++++++++++++++++

Editar descripción::
La edición de la descripción de guías clínicas es sencilla, simplemente consiste en la edición de meta-información de
las guías. Los requisitos que se piden son los siguientes: se debe poder editar el nombre de la guía, detalles del
autor principal, el estado del ciclo de vida de la guíafootnote:[Posibles estados: Ver todos los posibles valores en
https://openehr.atlassian.net/wiki/spaces/healthmod/pages/2949205/Archetype+Publication+Status], si la guía posee
_copyright_ debe existir un apartado para indicar quién es el propietario de dicho _copyright_, debe existir un
mecanismo
para gestionar palabras clave y colaboradores relacionados con la guía, así como una descripción que defina de forma
clara y concisa la misma, un propósito que indique claramente para qué se ha desarrollado, dos campos para indicar el
uso aconsejado y el desaconsejado de la guía y un medio para indicar referencias relacionadas con la guía clínica.

Editar definición::
La edición de las definiciones es más compleja. Las definiciones se encargan de enlazar los términos utilizados en
las guías con elementos de arquetipos. Para que el profesional sanitario pueda realizar dicha vinculación, primero
debe poder instanciar un arquetipo, es decir, debe poder seleccionar un arquetipo entre los disponibles, y poder
importarlo a la guía que esté elaborando para, posteriormente, poder instanciar elementos de dicho arquetipo
vinculándolos a variables locales de la guía (_i.e._ poder seleccionar elementos de arquetipos para utilizarlos en
nuestra guía).
+
Además de estas dos instanciaciones se deben poder establecer restricciones sobre la instanciación de arquetipos. Se
deben de poder añadir, eliminar y/o modificar predicados. Estos predicados definen restricciones para una instancia
de arquetipo, por lo tanto deben situarse dentro de la instanciación del mismo, mediante un componente de _drag and
drop_ que permita arrastrar cada predicado y poder soltarlo en la instancia de arquetipo correspondiente. Hay 4 tipos
de predicados :
+
* _Predicate (DataValue)_: este predicado tiene dos operandos y un operador. El operando izquierdo puede ser cualquier
elemento del arquetipo. El operador puede ser un operador de igualdad (==), de mayor o igual (>=), de menor o igual
(\<=) o un operador jerárquico (IS_A). El operando derecho debe de tener en cuenta dos cosas: el tipo de operador y
el tipo de datofootnote:[Cada elemento del arquetipo tiene un tipo de datos. Tipos de datos de __open__EHR:
http://www.openehr.org/releases/RM/latest/docs/data_types/data_types.html] del operador izquierdo, de tal manera que,
 si el operador es un operador jerárquico (IS_A) lo que se tiene que mostrar al editar el lado derecho es un árbol
 con las variables locales de la guía, se trata de que el predicado restrinja el valor de un elemento manifestando
 que este _es un_ elemento de la parte derecha. Si el operador no es  un operador jerárquico, entonces hay que tener
 en cuenta el tipo de dato del operando izquierdo. Los atributos de un DataValue vienen definidos por el
 <<_modelo_de_referencia, Modelo de Referencia>>, de tal modo que para cada tipo de dato hay que renderizar el
 formulario correspondiente para poder establecer la restricción, _e.g._ el tipo de dato _DV_QUANTITY_ tiene dos
 atributos (_magnitude_ y _units_), por lo tanto cuando el operando izquierdo sea de tipo _DV_QUANTITY_ al editar el
 operando derecho se debe renderizar un formulario con estos dos atributos.
+
* _Predicate (Function)_: se trata de un predicado unario, consta de un elemento y una función de agregación. De
momento GDL soporta dos funciones: _MAX_ y _MIN_ que obtienen el valor máximo y mínimo del elemento almacenado en la
HCE.
+
* _Predicate (Exists)_: es un predicado unario, consta de un elemento y de un valor ("existe" o "no existe"). Lo que
hace este predicado es comprobar si el elemento existe o no (si su valor es distinto de `null` o no).
+
* _Predicate (Expression)_: se trata de un predicado binario y consta de dos operandos y un operador. El primer
operando es un atributo de un elemento de un arquetipo. El operador puede ser un operador de igualdad (==), de mayor
o igual (>=) o de menor o igual (\<=). La edición del segundo operador depende del atributo del primer operador. Cada
tipo de dato tiene una serie de atributos que son los que regularán el segundo operador, _e.g._ si el atributo es un
_units_ de un _DV_QUANTITY_ se mostrará un combobox con las unidades en UCUMfootnote:[UCUM: Unified Code for Units of
 Measure, sistema de codificación para representar de forma inequívoca unidades de medida] para el atributo de ese
elemento o si el atributo es un _magnitude_ de _DV_AMOUNT_ se renderizará el <<_editor_de_expresiones, editor de
expresiones>> para que se pueda introducir un valor constante o una expresión.

Diseño
^^^^^^
La fase de diseño de esta segunda iteración se ha centrado en precisar los diagramas de los casos de uso descritos en
la fase de análisis. Para ello hacemos un refinamiento de los casos de uso que competen a esta iteración
afinando el nivel de detalle.

[[use-cases-iter-2]]
.Casos de uso de la iteración 2.
image::use-cases-iter-2.png[scaledwidth="90%"]

El diagrama de casos de uso de la segunda iteración se centra en dos casos de uso incluidos en _Editar guías
clínicas_, estos son _Editar descripción_ y _Editar definiciones_. Este último, debido a su complejidad, se ha
desgranado y se muestra con un nivel de detalle más fino para poder reflejar con mayor precisión las funcionalidades
que un profesional sanitario puede realizar cuando edita las definiciones de una guía clínica. Para editar las
definiciones, el usuario debe poder instanciar arquetipos, instanciar elementos de arquetipos y gestionar predicados.
Se muestran dos diagramas de secuencia: uno para mostrar el flujo de trabajo de lo que ocurre cuando se selecciona
una guía de la lista de guías disponibles y otro que ayuda a comprender cuál es el flujo de la aplicación cuando
se están editando las definiciones. En primer lugar se muestra qué ocurre cuando se selecciona una guía (este paso se
va a producir siempre cuando se empiece a editar una guía):

[[sequence-guideline]]
.Diagrama de actividades: seleccionando una guía.
image::sequence-guideline.png[]

Se verá con más detalle en la siguiente sección. Básicamente el usuario cuando selecciona una guía se obtiene un
objeto JSON enlazado con el `$scope` de AngularJS que representa dicha guía. Una vez seleccionada una guía
se puede editar cualquier sección de la misma usando las pestañas de la aplicación. Eligiendo la pestaña
_Definitions_ se pueden editar las definiciones, a continuación se muestra un diagrama de secuencia que muestra qué
ocurre por detrás cuando se instancia un arquetipo y un elemento de arquetipo.

[[sequence-elementInst]]
.Diagrama de actividades: instanciar un elemento de arquetipo.
image::sequence-elementInst.png[]

Para _Instanciar un predicado_, el procedimiento es similar, la instanciación de arquetipo es idéntica. Se arrastra
el predicado--de los cuatro disponibles--que se quiera instanciar y se suelta dentro de la instanciación de arquetipo
que se desee. A partir de entonces se puede seleccionar el operando (u operandos) y el operador del predicado.

Debido a las funcionalidades incorporadas en esta segunda iteración, en esta fase de diseño se ha elaborado un
diagrama de clases que manifiesta el comportamiento de cada uno de los componentes--controladores, factorías,
servicios, etc.--que intervienen en dichos escenarios, y las relaciones entre ellos.

[[classes-iter-2]]
.Diagrama de colaboraciones entre componentes en la iteración 2.
image::classes-iter-2.png[]

En el diagrama anterior se puede observar las dependencias entre los diferentes componentes, así vemos cómo _Editar
descripción_ depende de `guidelineFactory` principalmente para obtener los objetos que representan la ontología y la
descripción de la guía clínica. Los modales se han delegado todos en un servicio `modalService` con unas opciones por
defecto que pueden ser sobreescritas con los parámetros que queramos mostrar en dichos componentes gráficos. El caso
de uso _Editar definiciones_ utiliza el servicio `GuidelineFactory` que proporcionará los arquetipos con los que
está vinculados la guía actual, permite obtener loas descripciones de los términos utilizados en la guía, obtener la
ontología, etc. Utiliza el `modalService` para proporcionar los diálogos que facilitan la comunicación con el usuario
permitiendo seleccionar arquetipos y elementos de estos. la gestión de las expresiones (utilizadas en los predicados)
se delegan en el servicio `expressionItemFactory` y la gestión de los conceptos terminológicos en `terminologyFactory`.

Implementación
^^^^^^^^^^^^^^
La implementación de la segunda iteración se centra totalmente en el desarrollo de funcionalidad de la aplicación
(recordemos que parte de la primera iteración se centró en la configuración del proyecto AngularJS y en la decisión
de la estructura de directorios).

Como se muestra en la <<sequence-guideline>>, el profesional sanitario selecciona la pestaña _Guidelines_ (o se le
muestra por defecto al iniciarse la aplicación) donde puede ver el listado de guías clínicas. Al seleccionar una guía,
se llama a un método del controlador `GuidelineCtrl`, este método utiliza un servicio que se le ha inyectado
denominado `guidelineFactory`. Este servicio a su vez hace uso de un servicio nativo de AngularJS llamado `$http` el
cual hace una petición GET a la API REST. `$http` devuelve una promesa que, en cuanto se resuelva, se le asigna al
`$scope` del controlador `GuidelineCtrl`, en ese momento ya tenemos un objeto en memoria que representa la guía
clínica. En el momento que se resuelve la promesa que devuelve `$http`, `guidelineFactory` hace una petición de los
arquetipos que contiene la guía en su sección `archetypeBinding`. Esta petición se ha decidido hacerla en este punto,
y no cuando pasemos a editar las definiciones, porque mejora el rendimiento de tal modo que cuando se renderice la
vista de las definiciones el `$scope` ya cuente con los arquetipos en memoria, por lo que no tiene que hacer dicha
petición y la vista se carga de forma inmediata.

La implementación del primer caso de uso _Editar descripción_ es relativamente sencilla y se realiza en la vista de
la pestaña _Description_. Para ello se cuenta con la vista `tab-description.html` donde se implementan una serie de
paneles, cada uno de ellos destinado a los requisitos de información que se piden para este caso de uso (ver
<<use-case-desc-2, descripción de los casos de uso de la segunda iteración>>). A continuación se muestra un resumen
de la vista de la pestaña _Description_:

[source, html]
----
include::samples/description.html[]
----
<1> Uso de una directiva _transform-date_ para la manipulación de fechas.

Cabe mencionar el desarrollo de una directiva para la gestión de fechas. En AngularJS la manipulación de cualquier
elemento del DOM debe realizarse mediante una https://docs.angularjs.org/guide/directive[directiva]. A continuación se
muestra el código de la directiva `transformDate`.

[source,python]
----
include::../../app/components/tabs/tab-description/tab.description.directive.js[]
----

Se ha creado un controlador `DescriptionCtrl` para gestionar la vista anteriormente mencionada donde se declaran los
las propiedades del modelo que se vinculan con la vista. Como puede observarse en la plantilla HTML, se hace uso de la
directiva https://docs.angularjs.org/api/ng/directive/ngModel[ngModel] que vincula elementos del DOM con propiedades del
`$scope` de AngularJS. Además de esta vinculación se definen dos métodos para gestionar las palabras clave y
colaboradores. A continuación se muestra dicho controlador.

[source,python]
----
include::../../app/components/tabs/tab-description/tab.description.controller.js[]
----

La implementación del caso de uso _Editar definiciones_, al igual que el diseño, es más compleja que _Editar
descripción_. Uno de los requisitos de la aplicación fue que tanto la edición de las definiciones, como la de las
reglas y las precondiciones tendrían que ser utilizando un componente en forma de árbol con _drag and drop_, de manera
que el usuario pudiese ir generando las guías arrastrando y soltando los elementos correspondientes. Para este
cometido se ha utilizado un componente en forma de árbol llamado `ui-tree` (ver <<architecture>>). Este componente,
para gestionar su jerarquía, utiliza arrays de objetos y lo que queremos representar usándolo son objetos compuestos,
por lo que se ha tenido que trabajar con una transformación del modelo en memoria y hacer una reconversión en el
momento que se hace un POST de la guía.

Por motivos de limitación de espacio no se van a mostrar el controlador y el servicio de Angular que gestionan esta
funcionalidad. Para el desarrollo de la funcionalidad de editar las definiciones se ha implementado un controlador
llamado `DefinitionsCtrl` que se encarga de vincular el modelo de la definición de la ontología de la guía con la
vista `tab-definitions.html`. En la vista tenemos un panel principal donde se visualizan las definiciones y un panel
lateral derecho donde se muestran los diferentes elementos que podemos arrastrar y soltar para crear nuevas instancias.

[[implementation-iter-2]]
.Editar las definiciones de una guía.
image::implementation-iter-2.png[]

Para realizar nuevas instanciaciones se utiliza el panel derecho que cuenta con la directiva uiTree del módulo
`ui-tree` y se le pasa un objeto de configuración definido en el controlador (`treeDefinitions`) donde se le indica
que tiene que ser un árbol _clonable_ (aunque en este caso sólo tiene un nivel de anidamiento, el componente es un
árbol) y que al soltar cada uno de los elementos tiene que generar la definición correspondiente.

[source, html]
----
<div class="col-sm-3">
  <div ui-tree="vm.treeDefinitions" class="panel panel-default" data-clone-enabled="true" data-nodrop-enabled="true">
    <div class="panel-heading">
      <h2 class="panel-title">Definitions</h2>
    </div>
    <div class="panel-body">
      <ol ui-tree-nodes ng-model="vm.definitions">
        <li ng-repeat="item in vm.definitions" class="right-list" ui-tree-node data-nodrag="{{!item.draggable}}">
          <div ui-tree-handle>{{item.title}}</div>
        </li>
      </ol>
    </div>
  </div>
</div>
----

El objeto de configuración de este árbol se define en el controlador, se hace uso de un método de la propiedad
`$callbacks` del módulo, denominado `beforeDrop`, que se llama justo antes de que el objeto arrastrado sea soltado,
de manera que antes de soltar el elemento, genere la instanciación que corresponda.

[source, python]
----
vm.treeDefinitions = {
  beforeDrop: function(event) {
    var cloneModel = event.source.cloneModel;
    if(cloneModel.title === "Archetype instantiation") {
      definitionsFactory.createArchetypeInstantiation(cloneModel);
    } else if(cloneModel.title === "Element instantiation") {
      definitionsFactory.createElementInstantiation(cloneModel);
    } else if (cloneModel.ruleLine === "PredicateDatavalue") {
      definitionsFactory.createPredicateDatavalue(cloneModel);
    } else if (cloneModel.ruleLine === "PredicateFunction") {
      definitionsFactory.createPredicateFunction(cloneModel);
    } else if (cloneModel.ruleLine === "PredicateExists") {
      definitionsFactory.createPredicateExists(cloneModel);
    } else if (cloneModel.ruleLine === "PredicateExpression") {
      definitionsFactory.createPredicateExpression(cloneModel);
    }
  }
};
----

Como puede verse en el fragmento anterior, se utiliza un servicio denominado `definitionsFactory` que genera la
instanciación correspondiente dependiendo del nodo del panel derecho que se haya seleccionado. El panel principal
renderiza los `archetypeBindings` de la guía. En el modelo, un `archetypeBinding` se representa mediante un objeto JSON
con la siguiente estructura:

----
{
  "id": "gt0016",                                                           <1>
  "archetypeId": "openEHR-EHR-OBSERVATION.body_weight.v1",                  <2>
  "domain": "EHR",                                                          <3>
  "elements": {                                                             <4>
    "gt0005": {
      "id": "gt0005",
      "path": "/data[at0002]/events[at0003]/data[at0001]/items[at0004]"     <5>
    }
  },
  "predicates": [                                                           <6>
    "max(/data/events/time)"
  ],
  predicateStatements": [
    {
      "type": "UnaryExpression",
      "expressionItem": {
        "operand": {
          "type": "Variable",
          "expressionItem": {
            "path": "/data/events/time"
          }
        },
        "operator": "MAX"
      }
    }
  ]
}
----
<1> Identificador del _archetypeBinding_.
<2> Identificador del arquetipo al que se pretende enlazar.
<3> Espacio en el que residen las variables de regla: EHR o CDS.
<4> Lista de elementos definidos en el _archetypeBinding_ actual.
<5> _path_ unívoco del elemento en el arquetipo.
<6> Predicados definidos para el _archetypeBinding_ actual.

El controlador `DefinitionsCtrl` cuenta con diferentes métodos que permiten la edición de las definiciones, se
destacan varios métodos: un método `updateArchetype()` que permite actualizar un arquetipo seleccionándolo de una
lista de arquetipos (si se está sustituyendo por otro, automáticamente los elementos del arquetipo a sustituir se
eliminarían). Un método `updateLeftItem()` que permite actualizar tanto instanciaciones de elementos como de
predicados, en este último caso sería el elemento de la parte izquierda del predicado. Por último, mencionar el
método `updateRightItem()` que permite actualizar la parte derecha de los predicados, teniendo en cuenta el tipo de
dato del elemento de la parte izquierda, tal como se comentó en la definición de <<use-case-desc-2, casos de uso de
la iteración 2>>.

Pruebas
^^^^^^^
Siguiendo la guía de buenas prácticas, al fichero que contiene los test unitarios para testear el controlador
`DefinitionsCtrl` definido en el fichero `tab.definitions.controller.js`, le hemos llamado `tab.definitions.controller.spec.js`.

[source,python]
----
include::../../app/components/tabs/tab-description/tab.description.controller.spec.js[]
----

En este test se comprueba que el controlador se inicializa correctamente, que las propiedades que vinculan el modelo
con la vista están definidas, así como los métodos que gestionan las palabras clave y los colaboradores que contienen
las descripciones de las guías clínicas.

Iteración 3
~~~~~~~~~~~
Al término de la segunda iteración se ha obtenido un subsistema funcional que muestra las guías clínicas al usuario
para que pueda seleccionar una de ellas para editarla. Además permite editar la descripción de la guía y las
definiciones (enlaces de elementos de arquetipos a variables locales de las guías). En la tercera iteración se busca
acometer el desarrollo de otras dos funcionalidades: por un lado la edición de la lista de reglas de las guías y por
otro la edición de las precondiciones.

[[analisis-3]]
Análisis
^^^^^^^^
Para cumplir los objetivos marcados para esta tercera iteración, se implementan los casos de uso _Editar lista de
reglas_ y _Editar precondiciones_ de una guía clínica. Para ello se descomponen ambos casos de uso en factores de
casos de uso más simples.

Descripción de los casos de uso
+++++++++++++++++++++++++++++++

Crear nueva regla::
La pestaña _Rule list_ muestra un listado de todas las reglas definidas para una guía. A las reglas se les puede
asignar una prioridad para asegurar el orden de ejecución de las mismas--puede haber reglas que dependan de otras
anteriores--. La lista se muestra en un componente _drag and drop_ de modo que podamos arrastrar y soltar cada regla
pudiendo asignar la posición de esa manera.

Editar regla::
Edición del nombre de la regla. Desde la propia lista se puede modificar su nombre.

Eliminar regla::
Descarta la regla, eliminando intrínsecamente sus condiciones y sus acciones.

Gestionar condiciones::
GDL es independiente de tecnologías y se puede implementar usando diferentes motores de reglas. Ha sido diseñado para
que sus expresiones sean lo más parecido posible a las expresiones de reglas de negocio de los principales motores,
_i.e._ un conjunto de condiciones y un conjunto de acciones. La edición de condiciones y acciones es muy similar a la
de las definiciones. La versión actual de GDL soporta seis tipos de condiciones:

* _Compare (DataValue)_: compara el valor de una instancia de elemento con un valor de datos (constante).
* _Compare (NullValue)_: compara el valor nulo de una instancia de elemento con un código __open__EHR NULL_FLAVOUR.
* _Compare (Element)_: compara el valor de una instancia de elemento con el valor de otra instancia de elemento.
* _Compare (Attribute)_: compara el atributo de una instancia de elemento con una constante o una expresión (véase
<<_editor_de_expresiones, Editor de expresiones>>).
* _Element exists_: comprueba si la instancia del elemento tiene o no tiene ningún valor asignado.
* _Or operator_: realiza una disyunción lógica entre dos condiciones.

Gestionar acciones::
Se trata de las acciones que se ejecutan cuando se cumplen las condiciones, actualmente se soportan cuatro tipos de
acciones:

* _Set (DataValue)_: inicializa la instancia del elemento con el valor de datos seleccionado.
* _Set (NullValue)_: elimina el valor de la instancia del elemento y establece el código NULL_FLAVOUR seleccionado.
* _Set (Element)_: copia el valor de una instancia de elemento a otra.
* _Set (Attribute)_: establece el valor de un atributo utilizando una constante o una expresión (consulte
<<_editor_de_expresiones, Editor de expresiones>>).

Gestionar precondiciones::
Se trata de una serie de condiciones que se tienen que cumplir para que la guía pueda ser ejecutada. Las precondiciones
se gestionan en la pestaña _Preconditions_, de manera similar a cómo se gestionan las _condiciones_ y las _acciones_.
Poseen su propio editor de precondiciones. Están soportados los mismos tipos de precondiciones que de condiciones,
_i.e._ _Compare (DataValue)_, _Compare (NullValue)_, _Compare (Element)_, _Compare (Attribute)_, _Element exists_ y
_Or operator_.

Diseño
^^^^^^
En la fase de diseño de la tercera iteración se han dedicado esfuerzos a detallar los diagramas de casos de uso
concretados en la fase análisis. Para ello hemos descompuesto los escenarios de la edición de las reglas y de las
precondiciones en casos de uso más simples.

[[use-cases-iter-3]]
.Casos de uso de la iteración 3.
image::use-cases-iter-3.png[scaledwidth="90%"]

De los dos escenarios que se incorporan en esta iteración, se ha elaborado de un diagrama de clases para la
funcionalidad de edición de reglas--la edición de precondiciones se obvia, por ser más sencilla--donde se muestra el
comportamiento de controladores, factorías, servicios, etc. y las colaboraciones entre ellos.

[[classes-iter-3]]
.Diagrama de colaboraciones entre componentes en la iteración 3.
image::classes-iter-3.png[]

En el diagrama anterior se pone de manifiesto cómo el controlador que gestiona la lógica de negocio que hay tras la
lista de reglas (`RulelistCtrl`) depende de `guidelineFactory`, esto lo hace para obtener la ontología y para añadir o
eliminar reglas a una guía. Asimismo, el controlador que gestiona el editor de las reglas, `RuleEditorCtrl`, utiliza
dos servicios, `conditionFactory` y `actionFactory` para la gestión de los diferentes tipos de condiciones y acciones
respectivamente del editor. Se puede observar que también depende de `guidelineFactory` y de `expressionItemFactory`
para la gestión de las expresiones utilizadas tanto en las condiciones como en las acciones.

Implementación
^^^^^^^^^^^^^^
Para la tercera iteración se parte del hecho de que el usuario ha seleccionado una guía clínica y, por lo tanto,
se dispone de una representación JSON de dicha guía en memoria. En esta fase se transforma el resultado de las fases
anteriores en un subproyecto funcional que implemente los casos de uso descritos.

En cuanto a la edición de reglas GDL, como se puede ver en la <<gom>>, una guía clínica consta de una o varias reglas,
en concreto en la clase _GuideDefinition_ existe un atributo _rules_ que es un mapa de reglas, indexado por un
código _gt_ local. Por lo tanto, la primera vista al seleccionar la pestaña _Rulelist_ mostrará la lista de todas las
reglas definidas para la guía (ver <<rule-list>>). Además, este listado, tiene que ser ordenable ya que las reglas pueden tener
un orden de ejecución. La vista que renderiza este listado se muestra a continuación.

[source,html]
----
include::../../app/components/tabs/tab-rulelist/tab-rulelist.html[]
----

La lista se gestiona con el componente `ui-tree`, de manera que los nodos de la vista se puedan arrastrar y soltar
para indicar la prioridad de cada regla. Se implementa un botón que permite la adición de nuevas reglas y se
renderizan las ya creadas haciendo uso de la directiva https://docs.angularjs.org/api/ng/directive/ngRepeat[ngRepeat]
asignándole a cada una de ellas las funcionalidades de edición y de eliminado. Dentro del `ng-repeat` hacemos uso del
filtro nativo de Angular https://docs.angularjs.org/api/ng/filter/orderBy[orderBy], de modo que las reglas se
ordenarán automáticamente para su visualización. En el objeto de configuración que se le para a la directiva `uiTree`
se le indica que cuando se suelte un nodo se recalcule la prioridad de la guía dependiendo de donde se haya colocado
dicho nodo.

[source,python]
----
include::../../app/components/tabs/tab-rulelist/tab.rulelist.controller.js[]
----

El controlador `RulelistCtrl` es el que se encarga de gestionar la lógica de negocio que hay detrás de la vista
`tab-rulelist`. Al seleccionar una de las guías, se debe mostrar el editor de guías (ver <<rule-editing-2>>), para
abrir el editor de guías se hace uso del método `openRuleEditor` al cual le pasamos el identificador de la guía
seleccionada, para ello se hace uso del servicio
https://github.com/angular-ui/ui-router/wiki/URL-Routing#stateparams-service[$stateParams] del módulo `ui.router`
visto anteriormente. La vista del editor de reglas GDL se compone de dos paneles, un panel superior para las
condiciones y un panel inferior para las acciones. Cada uno de estos paneles tiene dos subpaneles, uno principal
donde se muestran las definiciones de las reglas y un panel lateral con los componentes _drag and drop_ necesarios
para la creación de dichas reglas, cuya funcionalidad se describió en la subsección de <<analisis-3, Análisis>>.
Tanto el código de la vista como el del controlador del editor de reglas no se muestran en la memoria por motivos de
espacio, pero se puede acceder al mismo en el https://github.com/jbarcas/angular-gdl-editor[repositorio de GitHub].
Cabe mencionar, como se puede ver en la <<classes-iter-3>>, que se han desarrollado dos servicios `ConditionFactory` y
`ActionFactory` sobre los que el controlador `RuleEditorCtrl` delega la funcionalidad de las condiciones y de las
acciones respectivamente del editor de reglas. Se ha hecho de esta manera para simplificar y delimitar mejor las
funcionalidades de cada una de ellas, obteniendo unos servicios más manejables y fáciles de comprender.

La implementación de las precondiciones es más sencilla y se ha desarrollado una vista muy parecida a la de las
condiciones.

[source,html]
----
include::../../app/components/tabs/tab-preconditions/tab-preconditions.html[]
----

Se utiliza el componente de árbol `ui.tree` para el renderizado de cada una de las precondiciones. Se recorre el
modelo que representa las precondiciones haciendo uso de `ng-repeat` y renderizando el operando izquierdo, el
operador y el operando derecho (en caso de que lo tenga) de cada una de ellas, asignando a cada uno de ellos el
manejador de eventos correspondiente. A continuación se muestra el controlador que gestiona la lógica de negocio que
hay tras la vista de las precondiciones.

[source,python]
----
include::../../app/components/tabs/tab-preconditions/tab.preconditions.controller.js[]
----

En el controlador `PreconditionsCtrl` define una serie de métodos para obtener las precondiciones de la guía y para
su gestión, cuya lógica de negocio la delega en los servicios `guidelineFactory`, `expressionItemFactory`,
`conditionFactory`, ya que esta lógica de negocio es reutilizada en otros controladores.

Pruebas
^^^^^^^
En esta sección se proporcionan los tests unitarios que se han desarrollado para las funcionalidades de la tercera
iteración. Como se ha comentado anteriormente, para el listado de las reglas de una guía clínica no se necesita hacer
ninguna llamada http ya que el modelo que representa la guía se encuentra asociado al `$scope` AngularJS, por lo
tanto no vamos a necesitar para este caso el servicio `$httpBackend`.

Debido a que los controladores no están disponibles en el ámbito global, necesitamos utilizar `angular.mock.inject`
para inyectar nuestro controlador `ruleListCtrl` primero. El primer paso es utilizar la función `module`
proporcionada por `angular-mocks`. Esto carga el módulo que se le pasa como parámetro, de manera que estaría
disponible en los tests. Pasamos esto en el `beforeEach`, que es la función que Jasmine proporciona que permite
ejecutar código antes de cada test. A partir de aquí se puede usar el método `inject` para tener acceso a `$controller`,
el servicio que es responsable de instanciar los controladores.

[source,python]
----
include::../../app/components/tabs/tab-rulelist/tab.rulelist.controller.spec.js[]
----

Se está utilizando la notación de guión bajo para tener una referencia global a los servicios inyectado en el
controlador, _i.e._ `guidelineFactory` y `rulelistFactory`.  Los guiones bajos serán ignorados por el inyector cuando
la referencia se resuelva. En el test anterior se comprueba la funcionalidad del controlador `RulelistCtrl`.

En el objeto `mock` definimos los resultados que esperamos para posteriormente compararlos con el resultado de las
operaciones que queremos llevar a cabo y comprobar si han funcionado o no. Una vez definidos los controladores con
sus servicios inyectados hacemos uso de la función https://jasmine.github.io/2.0/introduction.html#section-Spies[SpyOn]
de Jasmine. Primero se comprueban que tanto las propiedades como los métodos se han definido correctamente.
Posteriormente comprobamos que el método `getOntology` del servicio `guidelineFactory` ha sido llamado desde el
controlador y que ha devuelto correctamente la ontología de una guía clínica en particular (la que hemos definido en
el objeto `mock`).

El componente que se utiliza para renderizar la lista de reglas gestiona sus nodos (ítems de la lista) como un array.
En nuestro modelo, las reglas están representadas como un objeto, por lo que no son compatibles. Por lo tanto, se ha
tenido que realizar una conversión del objeto con las guías y transformarlo a un array. Esta función de utilidad es la
que se está probando en el último test, donde primero nos aseguramos que se ha obtenido la lista de reglas de la
guía actual y a continuación nos aseguramos que la propiedad `rules` definida en el controlador tiene la estructura
que se necesita para poder proporcionársela al componente que renderiza las guías.

Iteración 4
~~~~~~~~~~~
La iteración cuatro es la última y se ha tratado de dejar el proyecto en un estado funcional que comprendiese todas
las escenarios descritos en los objetivos del proyecto.

Análisis
^^^^^^^^
En esta última iteración se han implementado los restantes casos de uso, es decir, aquellas funcionalidades que
permitan editar la terminología de las guías, los enlaces con terminologías externas, visualizar el código GDL de la
guía clínica, así como una visualización en formato HTML de modo que el usuario pueda, con un sólo vistazo conocer
toda la información relacionada con la guía. Asimismo se necesita cubrir el caso de uso relacionado con el
almacenamiento de la guía modificada en el _backend_.

Descripción de los casos de uso.
+++++++++++++++++++++++++++++++

Editar terminología::
La edición de los términos utilizados en la guía se hace en la pestaña _Terminology_, donde se muestra una relación de
todas las definiciones de los términos locales encontrados en el GDL, que tienen la forma _[gtNNNN]_. Para cada uno de
los términos se muestra un campo con su código _gt_ local, un campo con el texto del término en sí, un campo para
indicar una descripción de dicho concepto y un mecanismo que permita gestionar cada término (editar cada uno de los
campos anteriores y/o eliminar dicho concepto).

Añadir términos locales::
Dentro de la edición terminología debe poderse añadir términos locales a la guía y darles un texto y una descripción.

Editar enlaces::
Se lleva a cabo en la pestaña _Binding_, se utiliza para describir las equivalencias entre los términos locales de
las guías clínicas y los términos que figuran en las terminologías externas. Para cada terminología con la que se
quiera enlazar y cada enlace debe mostrar su _código gt_ acompañado de su definición literal (el texto del término
mencionado en el caso de uso anterior), un listado de códigos con los que dicho término se puede enlazar y una URI
(esto último todavía no está soportado por GDL).

Añadir enlaces nuevos::
Para cada una de las terminologías se deben poder añadir nuevos enlaces. Para ello se seleccionará un término
existente en la guía y se podrán editar sus enlaces haciendo uso del caso de uso anteriormente mencionado.

Añadir terminologías a los enlaces::
Los enlaces se clasifican dependiendo a la terminología a la que hagan referencia. Se debe poder añadir una
terminología a la cual enlazar términos de una guía.

Eliminar terminologías de los enlaces::
De la misma manera que se añaden terminologías (ver caso de uso anterior), se deben poder eliminar dichas terminologías.

Visualizar GDL::
Visualización del código GDL que se está generando. Debe existir la posibilidad de almacenar la guía clínica en este
formato en local.

Visualizar la guía en formato HTML::
Visualización informativa de la guía actual en formato HTML, de forma que pueda verse de una manera amigable toda la
información de autoría y clínica de la guía

Almacenar guía clínica::
La guía que se está editando debe poder almacenarse en el _backend_ de la aplicación.

Diseño
^^^^^^
Con el fin de una mejor comprensión de los casos de uso que se pretenden abordar en esta última iteración,
se ha elaborado un diagrama de casos de uso que, al igual que en iteraciones anteriores, refina algunos casos de
uso base en casos de uso más simples.

[[use-cases-iter-4]]
.Casos de uso de la iteración 4.
image::use-cases-iter-4.png[scaledwidth="80%"]

Se han refinado los casos de uso _Editar terminologías_ y _Editar enlaces_. El primero ha dado lugar a un nuevo caso de
uso denominado _Añadir término local_ y del segundo han surgido los casos de uso _Añadir enlaces nuevos_, _Añadir
terminologías a los enlaces_ y _Eliminar terminologías de los enlaces_.

A continuación se muestra un diagrama de secuencia con una de las funcionalidades de esta iteración consistente en la
edición de un enlace terminológico.

[[sequence-editBinding]]
.Diagrama de secuencia para "Editar enlace".
image::sequence-editBinding.png[]

La edición de enlaces se hace en la pestaña _Binding_. En el momento que se activa dicha pestaña, automáticamente se
ejecuta el controlador que gestiona su vista (`tab-binding.html`) que, viendo el fichero `routes.js`, se trata de
`BindingCtrl`, que hará uso del método `getTermBindings` del servicio `guidelineFactory` que se le ha inyectado para
recuperar los enlaces a terminologías externas que tiene guía actual. Una vez recuperados se asignan al `$scope` de
Angular y se muestran al usuario (ver <<binding-1>>). Llegados a este punto el usuario tiene varias opciones como
editar cada enlace, eliminarlo, añadir una terminología-lo cual crearía una pestaña nueva para gestionar los
nuevos enlaces--, añadir un nuevo enlace a la terminología actual, eliminar la terminología actual--lo que haría
que se eliminasen todos sus enlaces y su pestaña asociada--y editar los enlaces a códigos de una terminología.

Al seleccionar la edición de enlaces, el controlador llama al servicio `TerminologyFactory` para que le devuelva los
términos de dicha terminología y poder mostrárselos al usuario, en un modal en forma de árbol--las terminologías son
jerárquicas--para que el usuario elija el código (o códigos) de la terminología con los que quiera vincular el
término de la guía. En el momento que el clínico seleccione un término, automáticamente se actualiza el modelo en
memoria y se renderiza la vista. Las demás funcionalidades mencionadas en el apartado anterior no se explicarán en
detalle por motivos de similitud con la funcionalidad mencionada, intervendrían los mismos componentes pero
realizando diferentes operaciones.

La edición terminológica de la guía tiene como finalidad permitir la edición de los términos locales utilizados en
las guías. Al activar la vista de la pestaña _Terminology_ donde se gestionan dichos términos, se ejecuta su
controlador asociad `TerminologyCtrl`, que vincula la ontología de la guía al contexto donde se almacena el modelo.
Una vez obtenida la ontología, se renderiza en una tabla editable cada uno de los términos que aparecen en la guía.
Esta tabla editable está indexada por el código _gt_ local de cada término y permite modificar tanto el texto como la
descripción de cada uno.

Los casos de uso _Visualizar GDL_ y _Visualizar la guía en formato HTML_ tienen un diseño bastante sencillo. Cada uno
cuenta con su propio controlador  (`GdlCtrl`y `HtmlCtrl`) y su propio servicio (`GdlFactory y HtmlFactory`). El
controlador delega en su servicio correspondiente la petición de su código fuente GDL o de su código HTML para ser
renderizado en la vista, el primero en un editor de textos y el segundo como HTML estático que ofrece una
visualización amigable del contenido tanto de descriptivo como clínico de la guía.

Implementación
^^^^^^^^^^^^^^
En esta fase de implementación de la última iteración se mencionan los detalles más significativos de las
funcionalidades que se acometieron en el _Sprint_. Para la edición de enlaces, tal como se ha visto en la sección
anterior, se ha desarrollado una vista `tab-bindings.html` que renderiza una tabla por cada terminología externa con
los enlaces a dichas terminologías (ver <<binding-1>>).

[source,html]
----
include::../../app/components/tabs/tab-binding/tab-bindings.html[]
----

En esta vista cabe mencionar que se cuenta con un componente de pestañas (_tabs_), que gestiona las terminologías a
las que se vinculan los conceptos locales de la guía. Este componentes de pestañas está sincronizado con la propiedad
`termBindings` definida en el controlador. Un ejemplo real del modelo de esta asociada a esta propiedad puede ser el
siguiente.

----
{
  "termBindings": {                     <1>
    "ICD10": {                          <2>
      "id": "ICD10",
      "bindings": {                     <3>
        "gt0100": {
          "id": "gt0100",               <4>
          "codes": [
            {
              "terminologyId": {
                "name": "ICD10",
                "value": "ICD10"
              },
              "codeString": "I50"       <5>
            }
          ],
          "uri": ""
        },
        "gt0101": {
          "id": "gt0101",
          "codes": [
            {
              "terminologyId": {
                "name": "ICD10",
                "value": "ICD10"
              },
              "codeString": "I12"
            },
            {
              "terminologyId": {
                "name": "ICD10",
                "value": "ICD10"
              },
              "codeString": "I13"
            }
          ],
          "uri": ""
        }
      }
    },
    "SNOMED-CT": {                      <6>
      "id": "SNOMED-CT",
      "bindings": {
        "gt0100": {
          "id": "gt0100",
          "codes": [
            {
              "terminologyId": {
                "name": "SNOMED-CT",
                "value": "SNOMED-CT"
              },
              "codeString": "42343007"
            }
          ],
          "uri": ""
        }
      }
    }
  }
}
----
<1> Propiedad `termBindins` asociada al `$scope`.
<2> Una terminología, en este caso ICD10.
<3> Los enlaces de la terminología ICD10.
<4> Término local que se quiere vincular con un terminología externa.
<5> El código (o códigos) de la terminología asociados al término local.
<6> Otra terminología, en este caso SNOMED CT.

En el ejemplo anterior vemos como se enlazan dos conceptos locales, _gt0100_ que se corresponde con "Insuficiencia
cardíaca" y _gt0101_ que se corresponde con "Hipertensión". El primero de ellos se enlaza con dos códigos de IDC10 y
el segundo con un código de SNOMED CT. Dentro de la tabla se hace uso de la directiva `ngRepeat` que recorre los
enlaces (ver propiedad `bindings` en el fragmento anterior) y renderiza sus campos asignándoles ciertos eventos y
manejadores que se definen en el controlador `BindingsCtrl` que no se mostrará explícitamente por cuestiones de
espacio, pero puede consultarse en el repositorio de código del proyecto.

La edición de la terminología de la guía (edición de términos locales) se hace a través de la vista `tab-terminology
.html` (ver <<terminology-1>>) que renderiza una tabla editable que permite modificar tanto el texto como la
descripción de cada termino. El módulo `xEditable` que se muestra en la <<architecture>> se utilizó para generar
dicha tabla, ya que el hecho de que fuese una tabla editable era un requisito de la aplicación. El controlador
`TerminologyCtrl` se trae a memoria la ontología de la guía y renderiza sus términos locales. Este controlador define
los métodos necesarios para la gestión de los términos locales.

Pruebas
^^^^^^^
A continuación se muestran los tests unitarios que se han desarrollado para probar las principales funcionalidades
que se abordaron en la última iteración.

Comenzando con el enlace a terminologías externas se decidió que las principales funcionalidades se podrían probar
testeando en controlador `BindingCtrl` que se ha definido de la siguiente manera.

[source,python]
----
include::../../app/components/tabs/tab-binding/tab.bindings.controller.spec.js[]
----

Se comienza el test cargando los módulos necesarios para ejecutar las funcionalidades que vamos a probar, al igual
que se ha hecho en iteraciones anteriores. Hacemos un _mock_ de una guía de pruebas para comprobar que los métodos
que testeamos del controlador van a devolver correctamente lo que se le solicita. A continuación, usando el servicio
`$controller`, se instancia el controlador que se quiere probar, en este caso, `BindingCtrl` con los servicios
inyectados que interesen para dichas funcionalidades. Las comprobaciones que se hacen para este controlador son, en
primer lugar, que el controlador esté definido. se comprueba que la propiedad `terminologies` utilizada
constantemente para esta funcionalidad esté definida y vacía antes de que se ejecute el controlador, que los métodos
`addBinding()`, `getCodes()`, `newBinding`, `newTerminology`, `removeBinding` , `removeBindingTerminology` están
definidos. A continuación se comprueba la que la propiedad `termBinding` se corresponde con el primer objeto--ya que
es el que se muestra por defecto--de la propiedad `termBindings`, se comprueba que su identificador es _ICD10_ y que
cuenta con 6 enlaces exactamente para esta guía clínica de pruebas. Finalmente, se hace la comprobación de que se ha
llamado  correctamente al método `getTermBindings` que devuelve todos los enlaces la guía, que se ha vinculado
correctamente con la propiedad del controlador `termBindings` y se comprueba que el objeto que contiene con los datos
es el correcto comparándolo con la guía clínica de pruebas.

Para la escenario relacionada con la gestión de los términos locales, se ha definido otra batería de tests en el
fichero `tab.terminology.controller.spec` en el que se han probado las funcionalidades que se han considerado más
importantes para la realización de su cometido.

Material utilizado
------------------

Sistema operativo Ubuntu 14.04 LTS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
El sistema operativo utilizado en el desarrollo de este proyecto es Ubuntu, versión 14.04 _Long Term Support_ de 64
bits, un sistema operativo basado en GNU/Linux y que se distribuye como software libre. Se ha elegido este sistema
operativo por la sencillez que presenta a la hora de instalar, integrar y trabajar con el resto de herramientas
utilizadas en el proyecto. Hay estadísticas webfootnote:[_Operating System Version Usage_ (en inglés): http://statowl.com/operating_system_market_share_by_os_version.php?1=1&timeframe=last_6&interval=month&chart_id=4&fltr_br=&fltr_os=&fltr_se=&fltr_cn=&limit%5B%5D=linux[statowl.com]]
que sugieren que la cuota de mercado de Ubuntu es del 49% dentro de las distribuciones de Linux, esto se debe a la
seguridad y estabilidad que ofrece.

Esta versión del sistema operativo fue lanzada en abril del 2014 y ofrece soporte de cinco años, hasta abril del 2019.
Cuenta con una comunidad de usuarios y de desarrolladores muy amplia y activa, por lo que existe mucha documentación
y foros a los que acudir en caso de que surja algún problema. Como entorno de escritorio se ha cambiado el que trae
por defecto, _Unity_ (interfaz de usuario desarrollada por Canonical, patrocinador de Ubuntu) por GNOME 3 por
considerar que posee un gestor de ventanas más intuitivo, más simple, con una mejor facilidad de uso y más eficiente.

IDE JetBrain WebStorm
~~~~~~~~~~~~~~~~~~~~~
Se ha utilizado el entorno de desarrollo integrado (IDE) _JetBrains WebStorm_ versión 10.01, antes denominado _JetBrains
IntelliJ WebStorm_. Se trata de un IDE orientado al ecosistema JavaScript moderno. Ofrece finalización de código
inteligente, detección de errores al vuelo, potente navegación y refactorización para JavaScript, TypeScript,
lenguajes de estilos y los _frameworks_ más populares. Se trata de una herramienta comercial. Se ha elegido este IDE
porque se integra perfectamente con AngularJS. Esta integración supone:

* _WebStorm_ conoce el código de AngularJS, ofrece completitud de código para directivas `ng` (también para directivas
personalizadas), para nombres de controladores y de aplicaciones y es consciente del código para la vinculación de
datos dentro de las expresiones dentro de las dobles llaves `{{}}`.
* Ofrece navegación específica de AngularJS
** Entre el nombre de un controlador en las vistas y su definición en JavaScript.
** Entre la directiva `ngView` o el _provider_ `$routeProvider` y la plantilla HTML
* Navegación 'Go to the symbol' para entidades.
* Incorpora una colección de plantillas predefinidas.
* Búsqueda rápida de documentación pulsando `Ctrl + Q`. Ver
https://www.jetbrains.com/help/webstorm/viewing-inline-documentation.html[documentación on-line] para más detalles.
* Soporte para diagramas `ui-router` de AngularJS.
* Cuenta con un depurador de aplicaciones cliente y Node.js muy sencillo de utilizar que permite la colocación de
puntos de interrupción en el código, explorar la pila de llamadas y variables, el uso de _timers_ y ofrece una consola
interactiva para la depuración.
* Permite la ejecución y depuración de tests unitarios con Karma, Mocha, Protractor y Jest. Permite observar
inmediatamente los resultados de las pruebas en el editor, o en una vista de árbol práctica desde la que puede saltar
rápidamente al test.
* Integración con sistemas de control de versiones: ofrece una interfaz de usuario amigable que se integra
perfectamente con Git y Github. Permite la realización sencilla de _commits_, revisión de cambios y resolución de
conflictos con una herramienta visual para hacer operaciones de `diff` y `merge` desde el propio IDE.

SGBD PostgreSQL
~~~~~~~~~~~~~~~
Como Sistema de Gestión de Bases de Datos (SGBD) se ha utilizado _PostgreSQL_, se trata de un SGBD relacional orientado
a objetos y libre, publicado bajo la licencia _PostgreSQL_,​ similar a la BSD o la MIT. Como muchos otros proyectos de
código abierto, el desarrollo de _PostgreSQL_ no es gestionado por una empresa o persona, sino que es dirigido por una
comunidad de desarrolladores que trabajan de forma desinteresada, altruista, libre o apoyados por organizaciones
comerciales. Dicha comunidad se denomina PGDG (_PostgreSQL_ Global Development Group). Se ha elegido este SGBD por
diferentes motivos: proporciona ahorros considerables de costes de operación, se trata de un sistema estable y
confiable ya que no se han presentado caídas importantes de la base de datos, es extensible, multiplataforma y
diseñado para contextos con altos volúmenes de datos. Además posee una herramienta gráfica de administración bastante
potente y sencilla de utilizar denominado https://www.pgadmin.org/[pgAdmin]. Proporciona una buena escalabilidad y un
buen sistema de seguridad.

Servidor de aplicaciones JBoss Server EAP 6.2
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
En este proyecto se ha utilizado el servidor de aplicaciones _JBoss Enterprise Application Platform_, versión 6.2
para el despliegue de la aplicación servidora (`km-server.war`). Se trata de un servidor de aplicaciones compatible
con Java EE, de código libre y, al estar basado en Java es multiplataforma, por lo que es posible su utilización en
cualquier sistema operativo que soporte Java. _JBoss EAP_ fue desarrollado por JBoss, ahora una división de Red Hat.

Han sido varios los motivos por los que se ha elegido _JBoss Server_ como servidor de aplicaciones y servicios ya que
soporta una serie de características como que soporta la especificación Java EE y los principales estándares de
servicios web, soporta Enterprise JavaBeans (EJBs), persistencia de entidades utilizando Hibernate, servicios web e
interoperabilidad incluyendo JAX-RPC, JAX-WS y JAX-RS entre otros. Se puede consultar un listado completo de las
funcionalidades que ofrece este servidor de aplicaciones en el apartado correspondiente de la página web oficial de
Red Hat JBossfootnote:[https://access.redhat.com/articles/112673].


Astah Community Edition como herramienta de modelado UML
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Se ha utilizado la versión _Community Edition_ de _Astah_ como herramienta de modelado UML para el diseño de
diagramas durante el desarrollo de la herramienta objeto de este TFM. _Astah Community_ permite la elaboración de
diagramas UML 2.x, esta versión ofrece unas funcionalidades gratuitas suficientes para la elaboración de diagramas de
en la fase de diseño. Permite la realización de:

* Diagramas de clases (objetos y paquetes).
* Diagrama de casos de uso:
* Diagrama de secuencias.
* Diagrama de comunicaciones.
* Diagrama de máquinas de estados.
* Diagrama de actividades.
* Diagrama de componentes.
* Diagrama de despliegue.
* Diagrama de estructuras compuestas.

Las siguientes funcionalidades son de pago:

* Organigramas.
* Diagramas de flujo de datos.
* Diagramas de Entidad-Relación.
* Diagramas CRUD.
* _Mindmaps_.

Además de ser una herramienta muy sencilla de utilizar, ofrece una serie de características que lo muy interesante,
como la ayuda a la alineación de componentes, permite búsquedas en los diagramas, generación de informes de
definición de entidades, etc.

AsciiDoc como herramienta de generación de documentación
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Esta memoria ha sido utilizando _AsciiDoc_ (ver https://github.com/jbarcas/angular-gdl-editor/blob/master/docs/source/memoria.txt[código fuente]),
se trata tanto del propio formato del fichero fuente como de la herramienta que compila dicho fichero a un documento
de salida. AsciiDoc es un lenguaje de marcado ligero para la creación de notas, artículos, documentación, libros,
páginas web, diapositivas y manual en texto plano. Los archivos de AsciiDoc se pueden traducir a muchos formatos
incluyendo HTML, PDF, EPUB, página de man.

AsciiDoc es altamente configurable: la sintaxis del fichero fuente _AsciiDoc_ y el marcado que se quiere como salida
del backend (que pueden ser casi cualquier tipo de marcado SGML/XML) puede ser personalizado y ampliado por el
usuario. _AsciiDoc_ es un software libre y está bajo los términos de la Licencia Pública General GNU versión 2
(GPLv2).

un documento _AsciiDoc_ se escribe de la misma manera que escribiría un documento de texto normal, no hay etiquetas de
marcado o notación de formato extraño. Los archivos _AsciiDoc_ están diseñados para ser vistos, editados e impresos
directamente o traducidos a otros formatos de presentación usando el comando
http://www.methods.co.nz/asciidoc/manpage.html[asciidoc].

El comando `asciidoc` traduce archivos _AsciiDoc_ a marcado HTML, XHTML y DocBook. DocBook puede ser post-procesado a
formatos de presentación como HTML, PDF, EPUB, DVI, LaTeX, roff y Postscript utilizando herramientas Open Source
disponibles fácilmente.

[[git-github]]
Git/Github como sistema de control de versiones y repositorio remoto de código
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
El control de versiones es un sistema que registra los cambios realizados sobre un archivo o conjunto de archivos a
lo largo del tiempo, de modo que puedas recuperar versiones específicas más adelante. Se ha utilizado el sistema de
control de versiones _Git_ para la gestión del código, esta herramienta gratuita, rápida y que se integra
perfectamente con la plataforma de alojamiento _Github_. _Git_ ofrece algunas ventajas sobre otros
SCVfootnote:[https://www.atlassian.com/git/tutorials/why-git]. En SVN por ejemplo, cada desarrollador obtiene una
copia de trabajo que apunta a un único repositorio central. _Git_, sin embargo, es un SCV distribuido. En lugar de una
copia de trabajo, cada desarrollador obtiene su propio repositorio local, con un historial completo de confirmaciones.

[[git]]
.Desarrollo distribuido de _Git_.
image::git.png[scaledwidth="60%"]

Tener una historia local completa hace que _Git_ sea rápido, ya que significa que no necesita una conexión de red para
crear _commits_, inspeccionar versiones anteriores de un archivo o realizar _diffs_ entre _commits_. Aunque no aplica al
desarrollo de este proyecto en particular, sí que podría afectar al futuro del proyecto el hecho de que el desarrollo
distribuido facilita la escalabilidad de su equipo de ingeniería. Si alguien rompe la rama de producción en SVN,
otros desarrolladores no pueden comprobar sus cambios hasta que se arreglen. Con _Git_, este tipo de bloqueo no existe.
Todo el mundo puede continuar con su trabajo en sus propios repositorios locales. El desarrollo distribuido crea un
ambiente más confiable. Incluso si un desarrollador borra su propio repositorio, simplemente puede clonar el de otra
persona y comenzar de nuevo.

_Github_ es una plataforma de desarrollo colaborativo, en este proyecto se ha utilizado
como repositorio para el alojamiento del código fuente y de los recursos necesarios para el desarrollo de la
aplicación. El proyecto con sus fuentes ha sido alojado en el repositorio
http://www.github.com/jbarcas/angular-gdl-editor/[github.com/jbarcas/angular-gdl-editor/].
Se ha utilizado por ser una plataforma de alojamiento que permite la creación de cuentas de usuario y de repositorios
de código de manera gratuita y por tener una excelente integración con el sistema de control de versiones _Git_ y con
el servicio de Integración Continua distribuido _Travis CI_.

ProjectLibre como software de gestión de proyectos
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
_ProjectLibre_, anteriormente denominada _OpenProj_ es un software de administración de proyectos diseñado como
sustituto de completo para Microsoft Project, capaz de abrir archivos de proyecto nativos de dicho programa.
ProjectLibre fue desarrollado por Projity en 2007. Se ejecuta en la máquina virtual de Java, lo que permite
ejecutarlo en una variedad de sistema operativos.

OpenProj dejó de estar en fase beta con el lanzamiento de la versión 1.0, el 10 de enero de 2008. Actualmente es
mantenido por https://www.projectlibre.com[ProjectLibre]. Es una versión gratuita y soporta las siguientes
características:

* Costos de valor acumulado.
* Diagramas de Gantt.
* Gráficos PERT.
* Estructuras de descomposición del recurso gráfico (EDR).
* Informes de uso de tareas.
* Diagramas de Estructura de Descomposición del Trabajo (EDT).
* Diagramas de red.
* Compatibilidad con Microsoft Project.

ProjectLibre es la principal alternativa de código abierto a Microsoft Project. Se ha descargado más de 3.000.000
de veces en más de 200 países y ha ganado el premio _Best of Open Source_. ProjectLibre es compatible con
los archivos de Microsoft Project 2003, 2007 y 2010.

El objetivo de _ProjectLibre_ es proporcionar un software de gestión de proyectos libre y de código abierto en todo el
mundo. Cuenta con funciones de administración de proyectos completas. ProjectLibre ha sido traducido a
más de veinte idiomas.

[[travis-ci]]
Travis CI como herramienta de integración continua
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Se ha una metodología ágil para el desarrollo de esta aplicación. Como es usual en este tipo de
metodologías se ha utilizado una herramienta de integración continua (IC), https://travis-ci.org/[_Travis CI_], Se
trata de un servicio de IC alojado, distribuido utilizado para construir y probar proyectos de software alojados en
GitHub.

Al ser una herramienta de código libre la desarrollada en este proyecto, se puede usar _Travis CI_ sin costes. Todos
los proyectos _open source_ pueden ser probados sin cargo a través de travis-ci.org. Los proyectos privados pueden ser
probados en travis-ci.com con un coste asociado. También existe un versión profesional _TravisPro_ que proporciona
implementaciones personalizadas de una versión propietaria en el propio hardware del cliente.

[[travis]]
.Consola de _Travis CI_.
image::travis.png[scaledwidth="85%"]

Travis CI se configura añadiendo un archivo denominado `.travis.yml`, que es un archivo de texto en formato
https://en.wikipedia.org/wiki/YAML[YAML], al directorio raíz del proyecto. Este archivo especifica el lenguaje
de programación utilizado, el entorno de construcción y pruebas deseado (incluidas las dependencias que deben
instalarse antes de que el software pueda ser construido y probado), además de otros parámetros de configuración.

A continuación se muestra el contenido del fichero `.travis.yml` utilizado en este proyecto.

----
include::../../.travis.yml[]
----

La elección de _travis CI_ frente a otras opciones como _Jenkins_, _Shippable_, _drone.io_ porque es un servicio
hospedado de modo que no hay que instalar ni configurar el servicio (sí requiere una pequeña configuración
del proyecto como se acaba de mostrar en el fichero `.travis.yml`). Otra razón ha sido que se trata de una herramienta
gratuita para proyectos _open source_ y además cuenta con una perfecta integración con _GitHub_, de manera que,
cuando se hace un _commit_ en _GitHub_ automáticamente construye el proyecto de nuevo y ejecuta todos sus tests,
enviándose una notificación en caso de que algún test hubiese fallado.

Planificación y costes (planificación inicial vs. final) - (Opcional)
---------------------------------------------------------------------
En esta sección se expone la planificación temporal y económica relacionada con el desarrollo de este proyecto. Para
ello se proporciona, en primer lugar, una explicación detallada de cada una de las tareas que serán representadas
posteriormente de una manera gráfica con un diagrama de Gantt, donde se indica el tiempo dedicado a cada actividad, así
como las relaciones de precedencia que existen entre ellas. Para la elaboración del diagrama y del cálculo de costes
se ha utilizado la herramienta de gestión de proyectos Openproj, versión 1.4.

Formación::
Para la realización de este proyecto ha sido imprescindible recibir una formación básica en las tecnologías y en la
metodología para la elaboración del mismo. Este período de formación ha durado aproximadamente 4 meses y se ha
paralelizado con el desarrollo del proyecto.
+
En este período de formación se han adquirido los conocimientos necesarios en el estado de la cuestión en el que se
alberga
este proyecto, siendo un contexto bastante complejo, pero con bastante proyección. Se trata de conocimientos sobre
interoperabilidad clínica basada en arquetipos y en sistemas de soporte a la decisión médica. Por otro lado, ha sido
indispensable la adquisición de nociones referentes al framework MVC AngularJS, cuya curva de aprendizaje es un poco
dura, pero realmente resulta bastante productivo. También se han tenido que obtener nociones básicas del
funcionamiento del entorno de ejecución de Node.js, así como de su sistema de gestión de paquetes _npm_.

Reuniones::
Como se ha visto en la <<_aplicacion_de_scrum_en_el_proyecto>>, se ha utilizado una versión simplificada de la
metodología Scrum. Se han realizado tres tipos de reuniones en cada iteración; reuniones de planificación de cada
Sprint (_Sprint Planning_), reuniones de seguimiento que han tenido lugar una vez por semana con una duración
aproximada de 45 minutos donde se han tomado decisiones a corto plazo de la iteración actual y una _Sprint Review_ a
la finalización de cada Sprint. En estas reuniones han participado el autor del proyecto realizando funciones de
analista y el director profesional del proyecto.

Primera iteración::
La primera iteración se ha centrado en la definición de la arquitectura del proyecto AngularJS, en la especificación
de requisitos y en la elaboración de los casos de uso que realicen dichos requisitos. La principal funcionalidad a
abordar ha sido la de permitir la navegación entre las diferentes guías clínicas existentes en el _backend_, para
ello se han desarrollado los componentes de Angular necesarios y se ha hecho uso del _databinding_ y del contenedor
de inversión de control de AngularJS. Posteriormente se realizaron los tests unitarios correspondientes para probar
los controladores y servicios desarrollados.

Segunda iteración::
La segunda iteración ha abarcado las funcionalidades de la edición de la descripción y de la definición de las guías.
Se han analizado las funcionalidades requeridas y se han diseñado los diagramas que se han considerado oportunos para
plasmar dichas funcionalidades y para la documentación del proyecto. Se ha acompañado esta iteración de los tests
pertinentes que prueban las principales funcionalidades que se acometen en dicho Sprint.

Tercera iteración::
Esta iteración se centra en el refinamiento de la edición de guías, permitiendo la edición de reglas GDL y la edición
de las precondiciones. Esta iteración complementa las dos anteriores y tras su finalización ofrecen un subsistema
funcional que permite la edición de guías clínicas casi en su totalidad. Como en el resto de iteraciones, se realizan
los tests unitarios pertinentes.

Cuarta iteración::
La última iteración completa a las tres anteriores y deja el proyecto en un estado funcional que comprende todos los
casos de uso requeridos. Se describen los casos de uso referentes a esta última iteración y se lleva a cabo un diseño
de los principales componentes que se pretenden abordar. A partir de este análisis y este diseño se implementan los
correspondientes componentes que permiten la gestión de los términos locales de las guías, la vinculación con
terminologías de referencia externas y la visualización del GDL generado como una vista HTML con información de la
guía.

Realización de la memoria::
La realización de esta memoria se ha elaborado con _AsciiDoc_, una herramienta para la generación de documentación
basada en Python. En la memoria se recogen todos los detalles de los métodos y documentación utilizados durante el
desarrollo de este proyecto. Su elaboración se ha prolongado durante todo el tiempo invertido en la elaboración de
este Trabajo Fin de Máster.

Diagrama de Gantt::
A continuación se muestra el diagrama de Gantt con la planificación temporal del proyecto, desglosado por tareas
indicando la precedencia entre ellas, el comiendo y el fin de cada una y los recursos asociados a las mismas.

[[tasks]]
.Detalle de tareas del diagrama de Gantt.
image::tasks.png[scaledwidth="100%"]

[[gantt]]
.Diagrama de Gantt.
image::gantt.png[scaledwidth="100%"]

Cálculo de costes::
En este apartado se muestra una estimación del coste total del proyecto que se ha elaborado teniendo en cuenta los
costes asociados a recursos humanos y los referentes a recursos materiales.

En cuanto a los recursos humanos, cabe destacar que el alumno asume diferentes roles durante las distintas fases del
proyecto. El cálculo de los costes se asigna de la siguiente manera: las fases de análisis y diseño las realiza un
analista, la fase de implementación la realiza un programador y la de pruebas la realizan conjuntamente analista y
programador con un porcentaje definido. Además del alumno, en las _Scrum meetings_ participa el tutor profesional que
asume el rol de _director del proyecto_.

El coste por hora de cada rol se ha calculado a partir del salario medio para cada categoría, para ello esta estimación
se ha basado en un estudio realizado en la propuesta del Grado de Ingeniería Informática de la Universidad de A
Coruña. Dichos costes hacen mención al salario bruto que recibe el trabajador y los costes de contratación.

Las horas de trabajo se han calculado utilizando el proyecto desarrollado en Openproj, asumiendo una jornada
laboral de 4 horas diarias de lunes a viernes, teniendo en cuenta las horas dedicadas a las reuniones. Para este
cálculo se suman las horas dedicadas por parte del director del proyecto durante todo el proceso de desarrollo. Los
cálculos derivados de recursos humanos se muestra en la siguiente tabla.

.Coste de recursos humanos.
[cols="25%,^25%,^25%,^25%", options="header"]
|===
|Personal           |Coste por hora                 |Horas trabajadas               |Total
|Analista           |20 €                           |445                            |8.900 €
|Programador        |12 €                           |528                            |6.336 €
|Jefe de proyecto   |24 €                           |35                             |840 €
3+>s|Total: ^|16.076 €
|===

Como se ha plasmado en el proyecto desarrollado en Openproj, también existe una serie de recursos a parte de los
humos, estos son los recursos materiales que se deben cuantificar en los costes del proyecto. En la realización de
este proyecto se utilizaron recursos materiales como un ordenador portátil y un conjunto de herramientas software
adecuadas, el coste de dichos recursos se ha calculado consultando a los proveedores de los mismos.

.Coste de recursos materiales.
[cols="75%,^25%", options="header"]
|===
|Elemento                               |Coste
|Ordenador portátil                     |800 €
|Licencia WebStorm 10.01 (primer año)   |126 €
>s|Total:                               |926 €
|===

Finalmente habría que añadir un coste adicional de 20€ por cada reunión en concepto de gastos de desplazamiento y
dietas. Se han realizado un total de 24 reuniones, por lo que, por este concepto, sumaría un total de 480 €. Para
obtener el coste total asignado a este proyecto se suman los costes parciales de recursos humanos, recursos
materiales, dietas y desplazamientos, que se pueden visualizar en la siguiente tabla.

.Coste total de la aplicación.
[cols="75%,^25%", options="header"]
|===
|Tipo de coste                  |Coste
|Coste de recursos humanos      |16.076 €
|Coste de recursos materiales   |926 €
|Coste de reuniones             |480 €
>s|Total:                       |17.482 €
|===

Resultados
----------
En esta sección se presentan los resultados obtenidos del proyecto, que muestran una mejora general con respecto a lo
existente, lo cual se consigue permitiendo la edición de guías clínicas GDL a través de Internet utilizando un
navegador web. A continuación se destacan los aspectos más importantes de dichos resultados, esta aplicación web:

* Ha sido desarrollada utilizando una versión simplificada de la metodología Scrum, lo cual ha permitido ir
obteniendo subproductos funcionales en cada una de las iteraciones en las que se ha dividido el proyecto. En dicho
desarrollo se han aplicado reconocidos patrones de diseño y se han utilizado tecnologías modernas de desarrollo web
como el entorno de ejecución multiplataforma para la capa del servidor Node.js y el framework para la creaciones de
aplicaciones de web de una sola página AngularJS.

* Es un producto de código libre, de utilidad para la empresa _Cambio Healthcare Systems_ y, en general, para cualquier
organización del sector sanitario que desee elaborar y trabajar con guías clínicas basadas en GDL, de modo que estas
guías permitan el intercambio de conocimiento médico de una manera consensuada y semánticamente interoperable.

* Permite a los profesionales sanitarios la elaboración de nuevas guías clínicas basadas en arquetipos, así como la
edición y eliminación de las mismas.

* La aplicación está preparada para ser integrada en el CKM de __open__EHR
(http://www.openehr.org/ckm[www.openehr.org/ckm]) y, en general, en cualquier servidor que soporte el despliegue de
aplicaciones web.

* Al ser una aplicación web, accesible a todo el mundo a través de Internet, se ha creado un mecanismo que brinda la
oportunidad a los profesionales sanitarios a que colaboren en la creación de conocimiento clínico y puedan llevar a
cabo un consenso sobre sus guías clínicas.

* Se ha desarrollado utilizando una aproximación basada en componentes, de forma que cada uno de ellos tiene su
propia lógica, lo cual facilita tanto la incorporación de nuevas funcionalidades como la eliminación de las mismas.
La utilización de componentes hace que la ejecución sea más fluida.

* Cuenta con una interfaz gráfica que ha sido diseñada utilizando recomendaciones de diseño, la cual proporciona una
usabilidad agradable de cara al usuario. La navegación entre las diferentes vistas hace uso del patrón _Composite
view_ permite la composición de vistas que se renderizan de manera independiente.

Conclusiones
------------
A continuación se mencionan las principales conclusiones que se han obtenido tras la realización de este proyecto.

* El contexto en el que reside este proyecto se encuentra en auge hoy en día a nivel internacional. En España el
https://www.msssi.gob.es/profesionales/hcdsns/areaRecursosSem/Rec_mod_clinico_arquetipos.htm[Ministerio de Sanidad]
está fomentando el uso de arquetipos clínicos en las herramientas de software médico barajándose la posibilidad de
que, en un futuro, sea obligatorio la comunicación de registros clínicos electrónicos utilizando este tipo de normas.
La mayoría gobiernos a nivel internacional están trabajando en el mismo sentido apostando por la interoperabilidad
semántica en la medicina, ya que es evidente la necesidad de que la información sanitaria del ciudadano pueda estar
accesible desde cualquier lugar y en cualquier momento.

* La curva de aprendizaje de estos estándares para desarrolladores es compleja debido a la dificultad de
representación de los datos clínicos, algo que es abordable con la normalización. Actualmente en este área se está
invirtiendo bastante dinero en investigación y están empezando a surgir _startups_ dedicadas exclusivamente al
desarrollo de herramientas que soporten estándares de interoperabilidad.

* A pesar de ser un ámbito en auge, no existen muchas herramientas para representar el conocimiento médico utilizando
estándares de  interoperabilidad. Para la edición de arquetipos clínicos
existe una aplicación de escritorio denominada http://www.linkehr.com/[LinkEHR], aplicación comercial que permite la
generación de arquetipos de una manera visual, pero también tiene sus limitaciones.

* El framework AngularJS es adecuado para la construcción de aplicaciones web de una sola página como el desarrollado
en este proyecto, facilitando considerablemente la construcción del software, el mantenimiento y la prueba de
componentes mediante tests unitarios utilizando _Karma_ y _Jasmine_.

* Ha quedado un objetivo de ejecución de las guías clínicas ha podido llevarse a cabo por cuestiones de tiempo, la
funcionalidad está soportada en el _backend_, pero la elaboración de formularios para los diferentes tipos de datos
no ha podido alcanzarse, dejándose como trabajo futuro como se verá a continuación.

* La utilización de guías clínicas basadas en estándares de interoperabilidad van a permitir almacenar información de
una manera normalizada, por lo que dicha normalización de los datos provocará un impacto positivo en investigación
sanitaria, farmacéutica, estadística y en general en todas aquellas actividades en las que la información deba
viajar de una organización a otra.

* La herramienta ha sido probada por profesionales sanitarios y se cree que la formación de los mismos no va a
ser costosa, debido a la sencillez la interfaz de usuario y a la especial dedicación que se ha mostrado para el
proceso de definición de las guías utilizando un componente _drag and drop_ que permite la creación de las guías
arrastrando componentes de una manera muy visual, proporcionando una excelente experiencia de usuario.

Futuros trabajos
----------------
Una aplicación web de estas características supone el punto de partida hacia una serie de nuevas funcionalidades de
gran utilidad para la comunidad. A continuación se detallan las más importantes que probablemente serán añadidas a la
aplicación a corto plazo.

* Edición colaborativa en tiempo real: un caso de uso muy interesante que ofrece la posibilidad de trabajar en el
documento GDL en colaboración con otros profesionales médicos. Habría que diseñar un mecanismo que permitiese el acceso
simultáneo a varios usuarios a la guía editada, indicando de alguna manera qué elementos están siendo editados por
otros usuarios y realizando una sincronización de las modificaciones con un clic de ratón. Como se da en otras
herramientas de edición colaborativa, quizás sería interesante añadir un chat para compartir ideas respecto a las
partes de la guía que están siendo modificadas.

* Resolución de conflictos: del punto anterior se desprende esta futura funcionalidad. Al haber varios usuarios
simultáneamente habría que plantear un medio de resolución de conflictos a la hora de almacenar los cambios de la
guía cuando dos o más usuarios hayan modificado un mismo elemento.

* Gestión del historial y de versiones: con la modificación de una guía aparece el concepto de versión de una guía
clínica. La versión de las guías clínicas, al igual que en los arquetipos, se indica en el propio nombre del fichero
GDL. Con la edición colaborativa habría que diseñar un mecanismo de gestión automática de guías.

* Internacionalización de la aplicación: de momento la aplicación se encuentra en idioma inglés ya que fue unos de
los requisitos impuestos. Una funcionalidad a corto plazo es la de permitir elegir el idioma de la interfaz gráfica.
Asimismo, se pretende añadir a corto plazo el soporte de términos locales (pestaña _Terminology_) en cualquier idioma.

* Soporte para Slots: como se ha comentado a lo largo de la memoria, los arquetipos son jerárquicos. Un arquetipo se
puede reutilizar para definir un nodo de otro arquetipo, esto se llama _slot_. En el arquetipo se puede definir
explícitamente, o con patrones de expresiones regulares, qué arquetipos acepta (o rechaza) que sean insertados en
dicho nodo. Es una situación poco común, pero la versión actual del editor GDL no puede resolver dichos _slots_. Se
pretende resolver esta situación a corto plazo.

* Por último, mencionar el objetivo no alcanzado de la ejecución de guías clínicas. Como se comentó en el
apartado anterior la funcionalidad de la compilación de guías está disponible en el _backend_. Se trata de una
utilidad adicional que permite la ejecución de las guías para que puedan probarse. Dicha funcionalidad generará un
formulario con un conjunto de entradas basado en el contenido definido en la guía. Estos datos se usarán para
ejecutar las reglas definidas en la guía y presentar el resultado con los valores calculados. Un ejemplo sencillo,
sobre la guía creada en el Manual de usuario (cálculo del IMC), sería la implementación de un componente gráfico que
al utilizarlo renderizase un formulario para que se introdujese el peso y la altura del individuo, la ejecución se
realizaría en el servidor teniendo en cuenta las reglas y las precondiciones y el sistema devolvería los datos
calculados al usuario.

[appendix]
Apéndices
---------
A continuación se detallan los apéndices referenciados durante la memoria de este Trabajo Fin de Máster.

Manual de usuario
~~~~~~~~~~~~~~~~~
El editor GDL se divide en 9 pestañas:

* Guidelines: listado de todas las guías disponibles en el _backend_.
* Description: información básica sobre la guía clínica.
* Definitions: referencias a los arquetipos utilizados en las reglas y en las precondiciones.
* Rule list: permite la gestión de todas las reglas dentro de la guía.
* Preconditions: una lista de las condiciones que se tienen que cumplir para que la guía pueda ser ejecutada.
* Terminology: traducciones para cada uno de los términos usados en las guías.
* Binding: mapeo de los códigos locales utilizados en la guía a terminologías externas.
* GDL: la salida del editor (en formato GDL)
* HTML: la salida del editor (en formato HTML)

Guidelines
^^^^^^^^^^
Se trata de la vista donde se muestra un listado con todas las guías clínicas, se puede seleccionar una guía para ser
editada, para ello el usuario se debe mover por las pestañas que se muestran a continuación.

.Guidelines: visualización de las guías disponibles.
image::iteration-1.png[]

Description
^^^^^^^^^^^
Esta sección define a grandes rasgos el uso y el propósito de la guía clínica con un conjunto de meta-datos. Incluye el
nombre único de la
guía, la
identificación unívoca del
autor responsable de la descripción, que puede incluir la organización a la que pertenece y/o información de contacto;
un enunciado formal, en lenguaje natural o codificado, definiendo el ámbito y el propósito clínico de la guía; una
lista de palabras clave, médicas o procedimentales, así como un listado de otros colaboradores que hayan aportado
trabajo a la guía clínica. Esta sección también puede incluir un enunciado sobre  el uso pretendido de la guía y un
enunciado sobre posibles usos erróneos o desaconsejados de la misma. La definición de una guía clínica GDL también
debe indicar información del _status_ de publicación (“Draft”, “Public”, “Deprecated”, etc.) footnote:[Ver todos los
posibles valores en https://openehr.atlassian.net/wiki/spaces/healthmod/pages/2949205/Archetype+Publication+Status]
y la fecha en la que se realizó dicha guía con este status de publicación. Por último existe un apartado donde se
pueden indicar referencias relevantes para la guía.

.Description: meta-información de la guía clínica.
image::description.png[]

Definitions
^^^^^^^^^^^
Las definiciones establecen un enlace entre elementos de arquetipos y los términos utilizados en nuestra guía. Todas
las definiciones de la guía se pueden encontrar en la pestaña _Definitions_, y pueden ser creadas desde aquí o
directamente desde los paneles de precondiciones/condiciones/acciones que veremos en las siguientes subsecciones.

Para crear una nueva definición en la pestaña _Definitions_ (<<definitions>>), simplemente arrastre y suelte las
definiciones (en el lado derecho) que desea insertar. Todos los componentes editables de cada definición se mostrarán
como un enlace (azul y subrayado). Para cambiar su valor, simplemente haga clic en él. Para eliminar una definición,
haga clic en el segundo botón (rojo).

[[definitions]]
.Definitions: definiciones de la guía.
image::definitions.png[]

Actualmente, GDL soporta cuatro tipos de definiciones:

* _Archetype instantiation_: crea una referencia a un arquetipo o plantilla. Para cada instanciación tendremos que
definir dos parámetros:
** _Domain_: hay tres posibles valores: _EHR_, _CDS_ y _ANY_ (<<definitions-2>>). Ver la especificación GDL para más
 información
sobre cada una de ellas.
** _Archetype/Template_: un listado con todos los arquetipos que se mostrarán.

[[definitions-2]]
.Definitions: elección de arquetipo.
image::definitions-2.png[]

* _Element instantiation_: crea una referencia a un elemento dentro del arquetipo o plantilla. Tiene que ser colocado
dentro de una instanciación de arquetipo.

[[definitions-3]]
.Definitions: elección de una instancia de elemento.
image::definitions-3.png[]

* _Predicate (DataValue)_: define una restricción para la instancia del arquetipo. Tiene que ser colocado dentro de
una instancia de arquetipo.
* _Predicate (Function)_: añade restricciones a los elementos definidos mediante el uso de funciones de agregación.

[[definitions-4]]
.Definitions: Funciones predicado.
image::definitions-4.png[]

Rule List
^^^^^^^^^
En esta pestaña podremos administrar todas las reglas de la guía. Cada regla contiene un conjunto de condiciones y
acciones (consultar <<_edicion_de_reglas>>). Para acceder a una regla, simplemente haga clic en su nombre.

La gestión de reglas es muy similar a las definiciones. Para agregar una nueva regla, utilice el botón _Add rule_
situado sobre la lista de reglas. Para editar el nombre de la regla, utilice el icono de lápiz y para eliminar una
regla haga clic sobre el botón rojo situado a la derecha del lápiz.

[[rule-list]]
.Lista de reglas.
image::rule-list.png[]

Edición de reglas
^^^^^^^^^^^^^^^^^
Cuando se accede a una regla, se mostrará el editor de reglas. La parte superior muestra las condiciones necesarias para
que la regla se ejecute, la parte inferior contiene las acciones que tendrán lugar una vez que se active la regla
(ver <<rule-editing-2>>). La mayoría de las acciones y condiciones se referirán a una instancia de elemento que puede
definirse
previamente en la sección _Definitions_ o directamente creada desde el editor de reglas. En el segundo caso, al
seleccionar una instancia de elemento desde una condición o una acción, se mostrará un cuadro de diálogo para
seleccionar / definir instancias de elemento. Este diálogo nos permitirá seleccionar una instancia de elemento ya
definida (<<rule-editing-1>>), una instancia de elemento de una instancia de arquetipo ya definida (2) o añadir una nueva
instancia de arquetipo (3).

[[rule-editing-1]]
.Edición de reglas: Seleccionar instancia de elemento.
image::rule-editing-1.png[]

La edición de condiciones y acciones es muy similar a la de las definiciones. La versión actual de GDL soporta seis
tipos de condiciones:

* _Compare (DataValue)_: compara el valor de una instancia de elemento con un valor de datos (constante).
* _Compare (NullValue)_: compara el valor nulo de una instancia de elemento con un código __open__EHR NULL_FLAVOUR.
* _Compare (Element)_: compara el valor de una instancia de elemento con el valor de otra instancia de elemento.
* _Compare (Attribute)_: compara el atributo de una instancia de elemento con una constante o una expresión (véase
<<_editor_de_expresiones, Editor de expresiones>>).
* _Element exists_: comprueba si la instancia del elemento tiene o no tiene ningún valor asignado.
* _Or operator_: realiza una disyunción lógica entre dos condiciones.

Actualmente se soportan cuatro tipos de acciones:

* _Set (DataValue)_: inicializa la instancia del elemento con el valor de datos seleccionado.
* _Set (NullValue)_: elimina el valor de la instancia del elemento y establece el código NULL_FLAVOUR seleccionado.
* _Set (Element)_: copia el valor de una instancia de elemento a otra.
* _Set (Attribute)_: establece el valor de un atributo utilizando una constante o una expresión (consulte
<<_editor_de_expresiones, Editor de expresiones>>).

[[rule-editing-2]]
.Editor de reglas.
image::rule-editing-2.png[]

Es importante tener en cuenta que sólo podremos realizar acciones en las instancias de elementos que correspondan a
una instancia de arquetipo en el dominio CDS. Esto significa que el motor de reglas no puede realizar cambios
directamente en los elementos de EHR.

Editor de expresiones
^^^^^^^^^^^^^^^^^^^^^
Los atributos de los elementos de arquetipos pueden compararse con expresiones que contienen otros atributos o
valores constantes. GDL soporta un conjunto básico de operadores aritméticos (ver <<operator-kind, operadores
aritméticos en las especificaciones GDL>>). El editor de expresiones se divide en dos partes, el panel de edición
(arriba) y el panel de visualización (abajo), cualquier cambio realizado en el panel de edición se mostrará en la
parte de visualización, siempre que la expresión sea correcta. Los elementos se pueden agregar a la expresión
manualmente o usar el asistente (lado derecho).

[[expression-editor]]
.Editor de expresiones.
image::expression-editor.png[]

Preconditions
^^^^^^^^^^^^^
Las precondiciones se gestionan de la misma manera que las condiciones en la <<_edicion_de_reglas, Edición de Reglas>>.
Esta sección define los hechos que se deben de cumplir antes de que la guía pueda ser ejecutada.

[[preconditions]]
.Precondiciones.
image::preconditions.png[]

En el ejemplo anterior, la guía sólo podrá ser ejecutada en el caso de que el paciente haya tenido fibrilación
auricular con anterioridad.

Terminología
^^^^^^^^^^^^
El editor de la terminología de la guía permite editar los diferentes términos encontrados en el GDL. Los códigos _gt_
se crean automáticamente cuando añadimos instancias de elemento o creamos nuevas reglas, pero tendrán que crearse
manualmente las vinculaciones a terminologías externas.

[[terminology-1]]
.Edición de la terminología.
image::terminology-1.png[]

Si se quiere añadir un nuevo término local, se hará haciendo clic en el botón _Add local term_, lo que creará un nuevo
término con el código gt local con un identificador cuyo valor sea el siguiente correlativo al último que haya en la
guía. A partir de aquí podremos editar su texto y su descripción.

[[terminology-2]]
.Edición de un término.
image::terminology-2.png[]

Binding
^^^^^^^
El enlace terminológico se gestiona desde la pestaña _Binding_. La tabla que se muestra aparecen los términos locales
que tenemos vinculados con terminologías externas. Un término puede estar vinculado con varias terminologías por lo
que estas aparecen como pestañas en la interfaz. Un término puede estar vinculado con varios códigos dentro de una
misma terminología.

Cuando se ejecuta la guía, cualquier código contenido aquí y referenciado con un operador _is_a_ será traducido a sus
terminologías vinculadas para su resolución. Cada fila en la tabla contiene tres columnas:

* Términos locales: los códigos definidos en la terminología local de la guía (ver TERMINOLOGÍA). Pueden
seleccionarse haciendo clic en el campo.
* Códigos terminológicos: los códigos de la terminología a la que estamos vinculados, separados por coma. Se puede
insertar manualmente o mediante el visor de terminología haciendo doble clic en el icono de la lupa.
* URI: un identificador de recurso uniforme que apunta a una expresión post-coordinación (en desarrollo).

[[binding-1]]
.Enlaces con terminologías.
image::binding-1.png[]

Al hacer clic en el botón 'Añadir terminología' podremos añadir una nueva pestaña con la terminología seleccionada
(las terminologías son recursos disponibles en el _backend_).

[[binding-2]]
.Añadir una nueva terminología.
image::binding-2.png[]

Para añadir un nuevo enlace, se debe hacer clic en el botón _New binding_. Esto abrirá un diálogo que nos pedirá el
nombre del nuevo código local, le creará un nuevo código _gt_ (el siguiente correlativo al último definido en la
guía) y nos permitirá vincularle el código que queramos de la terminología en la que estemos situados.

[[binding-3]]
.Asignar un código terminológico a una variable local a la guía.
image::binding-3.png[]

Código GDL
^^^^^^^^^^
La pestaña de código GDL muestra la guía editada en formato GDL. Cuando se visualiza, todas las secciones anteriores se
convertirán en lenguaje formal. Este es el mismo formato utilizado al guardar la guía en un archivo `.gdl`.

[[gdl-code]]
.Código GDL.
image::gdl-code.png[]

Vista HTML
^^^^^^^^^^
Esta pestaña permite la visualización de la guía GDL en formato HTML, de manera que se pueda visualizar la
información de la guía de una amanera más amigable de cara ala usuario.

[[html-view]]
.Vista HTML.
image::html-view.png[]


Ejemplo de creación de una guía clínica
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Cálculo del IMC (Índice de Masa Corporal)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Este ejemplo describirá cómo crear una guía simple para calcular el índice de masa corporal usando la fórmula:

latexmath:[IMC = masa(kg) / (altura(m))^2]

Para crear una nueva guía, hacemos clic en el botón _New Guideline_. Le damos un nombre a la guía y hacemos clic en
_OK_.

[[calculateBMI-1]]
.Creando una guía nueva.
image::calculateBMI-1.png[]

Después de completar este paso, debemos añadir cierta meta-información requerida para la guía. Esto se hace a través
de la pestaña _Description_.

[[calculateBMI-2]]
.Añadiendo meta-información relevante para la guía.
image::calculateBMI-2.png[]

En el siguiente paso, definimos los elementos de los arquetipos necesarios para la guía.

[[calculateBMI-3]]
.Definiendo elementos de arquetipos.
image::calculateBMI-3.png[]

Estos elementos, para el caso del _Cálculo del Índice de Masa Corporal_, se definen de la siguiente manera:

* Arrastramos la caja _Archetype instantiation_ del panel de la derecha y lo soltamos en el panel de las definiciones
(en la izquierda). Hacemos clic en _Select Archetype_ para seleccionar un arquetipo y seleccionamos
_openEHR-EHR-OBSERVATION.body_mass_index.v1_. De este arquetipo definimos el elemento _Body Mass Index_ bien
arrastrando la caja _Element instantiation_ o haciendo clic sobre el símbolo (+) del arquetipo, que nos permite
instanciar un elemento de dicho arquetipo.

* Arrastramos la caja _Archetype instantiation_ del panel de la derecha y lo soltamos en el panel de las definiciones
(en la izquierda). Hacemos clic en _Select Archetype_ para seleccionar un arquetipo y seleccionamos
_openEHR-EHR-OBSERVATION.body_weight.v1_. De este arquetipo definimos el elemento _Weight_ bien
arrastrando la caja _Element instantiation_ o haciendo clic sobre el símbolo (+) del arquetipo, que nos permite
instanciar un elemento de dicho arquetipo. Además, en este caso, vamos a indicarle que seleccione el peso más
reciente que haya disponible, para ello aplicamos la función de agregación _MAX_, arrastrando la caja _Predicate
(Function)_, soltándola bajo el arquetipo y seleccionado el elemento _Event time_.

* Arrastramos la caja _Archetype instantiation_ del panel de la derecha y lo soltamos en el panel de las definiciones
(en la izquierda). Hacemos clic en _Select Archetype_ para seleccionar un arquetipo y seleccionamos
_openEHR-EHR-OBSERVATION.height.v1_. De este arquetipo definimos el elemento _Height_ bien
arrastrando la caja _Element instantiation_ o haciendo clic sobre el símbolo (+) del arquetipo, que nos permite
instanciar un elemento de dicho arquetipo. Además, en este caso, vamos a indicarle que seleccione la altura más
reciente que haya disponible, para ello aplicamos la función de agregación _MAX_, arrastrando la caja _Predicate
(Function)_, soltándola bajo el arquetipo y seleccionado el elemento _Event time_.

El siguiente paso será añadir una regla, para ello seleccionamos la pestaña _Rule list_ y hacemos clic en el botón
_Add rule_. Insertamos el nombre de la regla y hacemos clic en _OK_.

[[calculateBMI-4]]
.Creando una nueva regla.
image::calculateBMI-4.png[]

Llegados a este punto, en la <<_rule_list, lista de reglas>> nos habrá aparecido la regla que acabamos de crear,
hacemos clic sobre ella para entrar en dicha regla, se abre el <<_edicion_de_reglas, Editor de reglas>>. Debemos
asegurarnos de que los elementos necesarios tengan las unidades correctas. Queremos añadir dos condiciones: el peso
se mide en kilogramos y la altura en centímetros. Arrastrando la condición _Compare (Attribute)_, agregaremos dos
condiciones vacías a la regla.

[[calculateBMI-5]]
.Añadiendo condiciones para especificar las unidades.
image::calculateBMI-5.png[]

Ahora podemos especificar las unidades para ambos elementos que vamos a obtener del EHR (peso y altura). Al hacer
clic en el enlace Elemento, podemos seleccionar el atributo que vamos a utilizar, tendremos los arquetipos que hemos
definido en la pestaña _Definitions_, de los cuales podremos obtener sus elementos.

[[calculateBMI-6]]
.Seleccionando un elemento del arquetipo.
image::calculateBMI-6.png[]

[[calculateBMI-7]]
.Estableciendo las condiciones.
image::calculateBMI-7.png[]

A continuación tendremos que añadir una acción que actualizará el atributo _magnitude_ del elemento _Body Mass Index_
del arquetipo _openEHR-EHR-OBSERVATION.body_mass_index.v1_. Arrastramos la acción _Set (Attribute)_, ubicado en el
panel inferior derecho. Seguimos los mismos pasos que antes para seleccionar unidades, pero en lugar de ello,
seleccionamos el atributo _magnitude_. Por ahora, la regla debe ser similar a la <<calculateBMI-8>>.

[[calculateBMI-8]]
.Seleccionada la magnitud del IMC.
image::calculateBMI-8.png[]

La última parte requiere definir la expresión para calcular el IMC. Hacemos clic en el enlace de Expresión para abrir
el editor de expresiones e introducimos la ecuación latexmath:[ (peso / (altura/100))^2]. Hacemos clic en el botón _OK_
para
agregar la expresión a la acción.

[[calculateBMI-9]]
.Expresión para el cálculo del IMC.
image::calculateBMI-9.png[]

Llegados a este punto se debería repetir la tarea para establecer las unidades y la precisión del elemento calculado.

Para esta guía no habrá precondiciones ya que no es necesario que se cumpla una condición para que la guía pueda ser
ejecutada.

En la pestaña _Terminology_ aparecen las descripciones terminológicas para los elementos que hemos definido,
para algunos de ellos ya toma la descripción que viene directamente en los arquetipos. Aquí podríamos proporcionar
definiciones de términos para el resto de variables locales de la guía, haciendo clic en _Add local term_.

[[calculateBMI-10]]
.Descripciones terminológicas para la guía.
image::calculateBMI-10.png[]

A continuación, se pueden establecer enlaces con terminologías externas desde la pestaña _Binding_. Para ello, se
añade la terminología con la queremos enlazar, en este caso hemos añadido _SNOMED-CT_ y _ICD10_. Para _SNOMED-CT_
hemos enlazado los conceptos Índice de Masa Corporal (IMC) y Peso, utilizados en la guía, con sus códigos SNOMED CT
correspondientes. Si queremos enlazar más conceptos lo hacemos utilizando el botón _New binding_, si lo que se quiere
es añadir una nueva terminología, la añadimos con _New terminology_ y si lo que queremos es eliminarla, lo hacemos
con el botón _Remove terminology_.

[[calculateBMI-11]]
.Añadiendo enlaces a terminologías externas.
image::calculateBMI-11.png[]

Las pestañas _GDL_ y _HTML_, tal como se comentó en <<_codigo_gdl>> y <<_vista_html>> respectivamente muestran una
visualización del código GDL y una vista con formato más amigable en HTML de la guía que estamos definiendo.

Una versión final del código GDL que se ha creado con esta guía lo podemos ver a continuación:

----
include::samples/Calculo.IMC.v1.gdl[]
----


Gramática de GDL
~~~~~~~~~~~~~~~~
La gramática y la especificación léxica para las expresiones utilizadas por GDL se basa en líneas generales en la
sintaxis de aserción en la especificación ADL. Esta gramática se implementa utilizando las especificaciones de
https://javacc.java.net/[javaCC] en el entorno de programación Java. El código fuente completo del analizador GDL de
Java se puede encontrar a continuación.
----
include::javacc/expression.jj[]
----

[bibliography]
Bibliografía
------------

[bibliography]
- [[[TURB11]]] E. Turban, R. Sharda, D. Delen, ``Decision Support and Business Intelligence Systems, 9^th^ ed.''. Pearson, 2011.
- [[[VERC09]]] C. Vercellis, ``Business Intelligence: Data Mining and Optimization for Decision Making''. Wiley Ltd, 2009. ISBN: 978-0-470-51138-1.
- [[[KEEN87]]] P. Keen, M. Scott Morton, ``Decision support systems: an organizational perspective''. Addison-Wesley. ISBN: 0-201-03667-3.
- [[[LEHM06]]] H. Lehman, P. Abbott, N. Roderer, A. Rothschild, _et al._ ``Aspects of electronic Health Record Systems''. Springer, 2006.
- [[[BONI04]]] J. Bonis, J. Sancho, F. Sanz, ``Computer-assisted Clinical Decision Support Systems''. Clinical Medicine, Elsevier Ed. 2004;122 Supl 1:39-44. (2004), pp. 75-81.DOI: https://doi.org/10.1157/13057545[10.1157/13057545], 2004.
- [[[BLEI69]]] HL. Bleich HL, ``Computer evaluation of acid-base disorders''. J Clin Invest, 48 (1969), pp. 1689-96. DOI: http://dx.doi.org/10.1172/JCI106134
- [[[IHTS17]]] ``International Health Terminology Standards Development Organisation''. URL: http://www.snomed.org/. Último acceso: junio 2017.
- [[[MSAN17]]] T. Benson, ``Principles of Health Interoperability HL7 and SNOMED''. London: Springer, 2012. ISBN: 978-1-4471-2800-7.
- [[[RUCH12]]] P. Ruch, J. Gobeill, C. Lovis, A. Geissbühler, ``Automatic medical encoding with SNOMED categories''. 2008. _BMC Medical Informatics and Decision Making_. DOI:https://bmcmedinformdecismak.biomedcentral.com/articles/10.1186/1472-6947-8-S1-S6[10.1186/1472-6947-8-S1-S6].
- [[[CIEM17]]] ``ICD-10 Second Edition, Volume 2'', World Health Organization, mayo de 2017. URL: http://www.who.int/classifications/icd/ICD-10_2nd_ed_volume2.pdf. Último acceso: agosto de 2017.
- [[[WARN61]]] H. Warner, A. Toronto, L. Veasey, R. Stephenson, ``Mathematical approach to medical diagnosis'' MD Comput, 1992.
- [[[NODE17]]] Web oficial de Node.js. URL: https://nodejs.org/es/. Último acceso: agosto 2017.
- [[[MUNO13]]] A. Muñoz _et al._ ``Manual práctico de interoperabilidad semántica para entornos sanitarios basada en
arquetipos''. Unidad de investigación en Telemedicina y e-Salud, Instituto de Salud Carlos III, julio de 2013.
- [[[AOM15]]] The __open__EHR Foundation. ``The __open__EHR Archetype Model. Archetype Object Model''.
URL: http://www.openehr.org/releases/trunk/architecture/am/aom2.pdf. The __open__EHR Foundation, 2015. Último acceso:
agosto 2017.
- [[[BEAL07]]] T. Beale, S. Heard, ``Archetype Definition Language''. The __openEHR__ Foundation, 2015.
- [[[CANT04]]] M. Cantelon, M. Harter, TJ. Holowaychuk, N. Rajlich, ``Node.js in Action''. Manning, 2013. ISBN:
9781617290572.
- [[[WEBA17]]] Wikipedia en español. URL: https://es.wikipedia.org/wiki/Aplicaci%C3%B3n_web. Último acceso: junio 2017.
- [[[MODU17]]] Documentación oficial de AngularJS. URL: https://docs.angularjs.org/guide/module. Último acceso: junio
  2017.
- [[[DIRE17]]] Documentación oficial de AngularJS. URL: https://docs.angularjs.org/guide/directive. Último acceso: junio
  2017.
- [[[DATA17]]] Documentación oficial de AngularJS. URL: https://docs.angularjs.org/guide/databinding. Último acceso:
  junio 2017.
- [[[SCRU12]]] P. Deemer, G. Benefield, C. Larman, B. Vodde. ``The Scrum Primer''. 2012.

[glossary]
Glosario
--------

[glossary]
[[X1]] Historia Clínica Electrónica::
  Registro electrónico de información demográfica, preventiva y médica de un paciente.

[[X2]] Document Object Model::
  Interfaz, independiente del lenguaje y plataforma que permite a programas y scripts acceder dinámicamente y
  actualizar el contenido, estructura y estilos de documentos HTML, XHTML y XML.

[[X3]] Clinical Knowledge Manager::
  Plataforma de desarrollo colaborativo, gestión y publicación de una amplia gama de recursos de conocimiento
  clínico de __open__EHR. Los recursos incluyen arquetipos, plantillas, subconjuntos terminológicos, metadatos
  relacionados con modelos clínicos y otros recursos relacionados.

[[X4]] Knowledge Manager::
  COSMIC CDS Knowledge Manager es una base de datos de conocimiento y un motor de reglas para la gestión de
  normalización médica y modelos de información clínica. El conocimiento clínico se desglosa en reglas interpretables
  por las máquinas basadas en estándares internacionales y terminologías de referencia, de modo que las reglas de
  soporte a la decisión pueden ser compartidas de forma sencilla entre diferentes aplicaciones de soporte a la
  decisión, independientemente del proveedor. Las reglas pueden ser usadas para construir un poderoso y flexible
  sistema de apoyo a la toma de decisiones clínicas.

[index]
Índice
------
////////////////////////////////////////////////////////////////
The index is normally left completely empty, it's contents being
generated automatically by the DocBook toolchain.
////////////////////////////////////////////////////////////////

